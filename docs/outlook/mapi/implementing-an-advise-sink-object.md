---
title: 实现通知接收器对象
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 7461c4f6-7030-4ba2-ada4-26ebfbbfa001
description: 上次修改时间：2015 年 3 月 9 日
ms.openlocfilehash: ecaad65d28f74b843b86ca82dab9a833ade77363
ms.sourcegitcommit: 8657170d071f9bcf680aba50b9c07f2a4fb82283
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/28/2019
ms.locfileid: "33412105"
---
# <a name="implementing-an-advise-sink-object"></a>实现通知接收器对象

  
  
**适用于**：Outlook 2013 | Outlook 2016 
  
客户端可以实施其自己的通知接收器对象或使用实用工具函数[HrAllocAdviseSink](hrallocadvisesink.md)。 **HrAllocAdviseSink**使用调用回调函数的**OnNotify**的实现创建一个通知接收器对象。 
  
使用**HrAllocAdviseSink**的优点和缺点各不相同。 它可以节省工作, 但不能控制对它创建的 "通知接收器" 对象进行计数的引用计数。 因此, 需要仔细控制其通知接收器发布或在其通知接收器和另一个客户端对象之间存在相互依赖关系的客户端应构造其自己的**IMAPIAdviseSink**实现, 从而避免使用**完全 HrAllocAdviseSink** 。 
  
实现自己的通知接收器的客户端应使其不与任何其他对象相关或依赖于任何其他对象的独立对象, 以避免引用计数和对象释放中的潜在麻烦。 但是, 如果您必须将您的通知接收器作为另一个对象的一部分实现或包含指向另一个对象的 back 指针作为数据成员, 则建议保留两个单独的引用计数: 一个用于通知接收器引用的对象, 另一个用于通知接收器。 
  
当被引用对象的引用计数为零时, 它的所有方法都可能会失败, 并且可以销毁它的 vtable, 但建议接收器的内存必须保持不变, 直到其引用计数也降为零。 这意味着, 通知接收器的**Release**方法必须减小其引用计数, 并在该计数达到零时完成对该对象的销毁。 如果不保留两个单独的引用计数, 则很容易在包含对象的**发布**过程中不小心销毁建议接收器。 
  
使用**HrAllocAdviseSink**实现通知接收器的客户端必须同样小心, 不要将其回调函数作为另一个建议接收器对象中的方法。 对于 c + + 客户端, 实现此目的并将_此_指针作为参数传递是很有吸引力的。 这是一种危险策略, 因为客户端通常会在其引用计数达到零时释放对象。 释放通知接收器对象的内存将导致_此_指针无效。 
  
根据事件的类型和建议源, **OnNotify**方法可以通过多种方式处理事件。 下表提供了有关如何处理一些标准事件的建议。 
  
|**事件类型**|**在 OnNotify 中处理**|
|:-----|:-----|
|移动的对象  <br/> |如果移动的对象的原始父对象与新的父对象相关联, 请从层次结构中最高的文件夹或通讯簿容器开始更新视图。 如果两个父容器不相关, 请更新其两个视图。  <br/> |
|新邮件  <br/> |更改用户界面以通知用户有一个或多个新邮件到达。 将接收文件夹放置在当前视图中。  <br/> |
|Error  <br/> |对于除会话之外的所有对象, 请记录错误 (如有必要) 并返回。 对于 session 对象, 请注销 (如果可能)。  <br/> |
|搜索完成  <br/> |无需处理。  <br/> |
   
> [!NOTE]
> 通知处理程序应是可重入的。 
  

