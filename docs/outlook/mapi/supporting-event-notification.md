---
title: 支持事件通知
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: a1e3e49c-8d1d-4f7e-ba5a-be441f0f10ae
description: 上次修改时间： 2011 年 7 月 23 日
ms.openlocfilehash: 1320528a2e123d36457bef929a8454155646f0da
ms.sourcegitcommit: 0cf39e5382b8c6f236c8a63c6036849ed3527ded
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/23/2018
ms.locfileid: "22580997"
---
# <a name="supporting-event-notification"></a><span data-ttu-id="e8f7e-103">支持事件通知</span><span class="sxs-lookup"><span data-stu-id="e8f7e-103">Supporting Event Notification</span></span>

  
  
<span data-ttu-id="e8f7e-104">**适用于**： Outlook 2013 |Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="e8f7e-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="e8f7e-105">支持事件通知可能非常复杂，因为 MAPI 提供三种支持对象方法的实现过程的最刁钻部分。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-105">Because supporting event notification can be complicated, MAPI supplies three support object methods that implement the most difficult parts of the process.</span></span> <span data-ttu-id="e8f7e-106">这些方法都作为一个单元，并提供程序必须使用所有这三个或其中任何一个。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-106">These methods work as a unit, and a provider must use all three or none of them.</span></span>
  
<span data-ttu-id="e8f7e-107">MAPI 支持方法使用通知键管理 advise 接收器生成通知的对象之间的连接。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-107">The MAPI support methods use notification keys to manage the connections between the advise sinks and the objects that generate the notifications.</span></span> <span data-ttu-id="e8f7e-108">通知密钥是包含跨进程标识对象的二进制数据的[NOTIFKEY](notifkey.md)结构。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-108">A notification key is a [NOTIFKEY](notifkey.md) structure that contains binary data that identifies an object across processes.</span></span> <span data-ttu-id="e8f7e-109">从 advise 源对象的长期条目标识符通常复制通知键。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-109">A notification key is typically copied from the long-term entry identifier of the advise source object.</span></span> <span data-ttu-id="e8f7e-110">如果客户端有提供对**Advise**的调用中的项标识符，您可以将其用于通知键。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-110">If the client has supplied an entry identifier in the call to **Advise**, you can use it for the notification key.</span></span> <span data-ttu-id="e8f7e-111">如果**Advise** _lpEntryID_参数为 NULL，则使用条目标识符圆周可能容器对象，如消息存储库。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-111">If the  _lpEntryID_ parameter to **Advise** is NULL, use the entry identifier of the outermost possible container object, such as the message store.</span></span> 
  
<span data-ttu-id="e8f7e-112">若要使用的支持方法，调用[IMAPISupport::Subscribe](imapisupport-subscribe.md)每当客户端调用注册通知您**Advise**方法。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-112">To use the support methods, call [IMAPISupport::Subscribe](imapisupport-subscribe.md) whenever a client calls your **Advise** method to register for a notification.</span></span> <span data-ttu-id="e8f7e-113">分配[NOTIFKEY](notifkey.md)结构并创建 advise 源对象的唯一通知键。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-113">Allocate a [NOTIFKEY](notifkey.md) structure and create a unique notification key for your advise source object.</span></span> <span data-ttu-id="e8f7e-114">例如，提示到特定文件夹时收到一条消息，通知客户端的消息存储提供程序创建该文件夹的通知键。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-114">For example, a message store provider that is prompted to notify a client when a message is received into a particular folder creates a notification key for that folder.</span></span> <span data-ttu-id="e8f7e-115">**NOTIFKEY**结构以及指向客户端的**Subscribe**的调用中传递一个指针建议接收器。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-115">Pass a pointer to the **NOTIFKEY** structure in the call to **Subscribe** along with a pointer to the client's advise sink.</span></span> <span data-ttu-id="e8f7e-116">**Subscribe**调用通知接收器[IUnknown::AddRef](http://msdn.microsoft.com/library/b4316efd-73d4-4995-b898-8025a316ba63%28Office.15%29.aspx)方法来增加引用计数和 MAPI 保留指针，直到被取消注册。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-116">**Subscribe** calls the advise sink's [IUnknown::AddRef](http://msdn.microsoft.com/library/b4316efd-73d4-4995-b898-8025a316ba63%28Office.15%29.aspx) method to increment its reference count and MAPI retains the pointer until the registration is canceled.</span></span> 
  
<span data-ttu-id="e8f7e-117">您可以传递 NOTIFY_SYNC 标志给**Subscribe**请求**Notify**行为同步，而不返回直到它所做的[IMAPIAdviseSink::OnNotify](imapiadvisesink-onnotify.md)方法的所有呼叫注册告知接收器。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-117">You can pass the NOTIFY_SYNC flag to **Subscribe** to request that **Notify** behave synchronously and not return until it has made all calls to the [IMAPIAdviseSink::OnNotify](imapiadvisesink-onnotify.md) methods of registered advise sinks.</span></span> <span data-ttu-id="e8f7e-118">设置仅供内部使用此标志。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-118">Set this flag only for your own internal use.</span></span> <span data-ttu-id="e8f7e-119">响应客户端**Advise**呼叫时，不要设置它。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-119">Do not set it when you respond to a client **Advise** call.</span></span> <span data-ttu-id="e8f7e-120">客户端和提供程序之间的事件通知始终是异步的。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-120">Event notification between clients and providers is always asynchronous.</span></span> <span data-ttu-id="e8f7e-121">即 MAPI 保证的呼叫期间事件发生之前所做的任何**OnNotify**呼叫将返回到客户端。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-121">That is, MAPI guarantees that the call during which an event happens will return to the client before any of the **OnNotify** calls are made.</span></span> 
  
<span data-ttu-id="e8f7e-122">如果您设置 NOTIFY_SYNC 标志，不到任何 advise 接收器对象，进行任何更改，并且不向传递到**Subscribe** [HrThisThreadAdviseSink](hrthisthreadadvisesink.md)创建包装通知接收器。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-122">If you set the NOTIFY_SYNC flag, do not make any changes to any of the advise sink objects, and do not pass a wrapper advise sink created by [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) to **Subscribe**.</span></span> <span data-ttu-id="e8f7e-123">**HrThisThreadAdviseSink**创建通知接收器用于仅异步通知的线程安全版本。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-123">**HrThisThreadAdviseSink** creates a thread-safe version of an advise sink to be used with asynchronous notification only.</span></span> 
  
<span data-ttu-id="e8f7e-124">如果设置了 CALLBACK_DISCONTINUE 标志情况下，为同步通知注册通知接收器返回从**OnNotify** ， [IMAPISupport::Notify](imapisupport-notify.md)设置 NOTIFY_CANCELED 标志，并返回不做任何调用**OnNotify**。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-124">If an advise sink registered for synchronous notification returns from **OnNotify** with the CALLBACK_DISCONTINUE flag set, [IMAPISupport::Notify](imapisupport-notify.md) sets the NOTIFY_CANCELED flag and returns without making any calls to **OnNotify**.</span></span> 
  
<span data-ttu-id="e8f7e-125">一旦返回了**订阅**，将不再能够留副本的任何需要客户端的建议接收器。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-125">Once **Subscribe** has returned, you will no longer have any need to hold onto your copy of the client's advise sink.</span></span> <span data-ttu-id="e8f7e-126">调用其释放其[IUnknown::Release](http://msdn.microsoft.com/library/4b494c6f-f0ee-4c35-ae45-ed956f40dc7a%28Office.15%29.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-126">Call its [IUnknown::Release](http://msdn.microsoft.com/library/4b494c6f-f0ee-4c35-ae45-ed956f40dc7a%28Office.15%29.aspx) method to release it.</span></span> <span data-ttu-id="e8f7e-127">**Subscribe**返回非零值的连接数应返回到客户端。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-127">**Subscribe** returns a nonzero connection number that you should return to the client.</span></span> <span data-ttu-id="e8f7e-128">连接的编号代表 advise 源和通知接收器之间的链接。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-128">The connection number represents the link between the advise source and the advise sink.</span></span> <span data-ttu-id="e8f7e-129">它在客户端调用成功**Unadvise**才有效。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-129">It remains valid until the client makes a successful call to **Unadvise**.</span></span> 
  
<span data-ttu-id="e8f7e-130">已准备好取消注册客户端时，它将调用您**Unadvise**方法。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-130">When the client is ready to cancel a registration, it calls your **Unadvise** method.</span></span> <span data-ttu-id="e8f7e-131">从[IMAPISupport::Unsubscribe](imapisupport-unsubscribe.md) **Unadvise**调用传递连接数。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-131">Pass the connection number from the **Unadvise** call to [IMAPISupport::Unsubscribe](imapisupport-unsubscribe.md).</span></span> <span data-ttu-id="e8f7e-132">**取消**呼叫通知接收器**IUnknown::Release**方法。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-132">**Unsubscribe** calls the advise sink's **IUnknown::Release** method.</span></span> <span data-ttu-id="e8f7e-133">如同**Advise**和**Unadvise**，必须配对**Subscribe**和**Unsubscribe**调用。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-133">As with **Advise** and **Unadvise**, calls to **Subscribe** and **Unsubscribe** must be paired.</span></span> <span data-ttu-id="e8f7e-134">您必须进行一次调用**取消**对**订阅**每个呼叫。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-134">You must make one call to **Unsubscribe** for every call that is made to **Subscribe**.</span></span> <span data-ttu-id="e8f7e-135">但是，不需要每次调用**Advise**方法调用**订阅**。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-135">However, you do not have to call **Subscribe** every time your **Advise** method is called.</span></span> <span data-ttu-id="e8f7e-136">相反，您可以设置内部通知调用它。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-136">Conversely, you can call it for setting up internal notifications.</span></span> 
  
<span data-ttu-id="e8f7e-137">事件发生时，分配适当的事件类型的一个或多个[通知](notification.md)结构，并调用[IMAPISupport::Notify](imapisupport-notify.md)。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-137">When an event occurs, allocate one or more [NOTIFICATION](notification.md) structures of the type appropriate for the event and call [IMAPISupport::Notify](imapisupport-notify.md).</span></span> <span data-ttu-id="e8f7e-138">**Notify**生成通知的每个已注册的通知接收器。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-138">**Notify** generates a notification for each registered advise sink.</span></span> <span data-ttu-id="e8f7e-139">应设置未使用的所有成员的[通知](notification.md)结构为零。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-139">You should set all the unused members of the [NOTIFICATION](notification.md) structure to zero.</span></span> <span data-ttu-id="e8f7e-140">此方法用于初始化**通知**结构可帮助更快，并减少出错**OnNotify**实现创建较短的客户端。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-140">This technique for initializing the **NOTIFICATION** structure can help clients create smaller, faster, and less error-prone **OnNotify** implementations.</span></span> 
  
<span data-ttu-id="e8f7e-141">请注意，单独的**通知**结构所必需的每个事件，即使的相同类型的多个事件。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-141">Note that a separate **NOTIFICATION** structure is necessary for each event, even for multiple events of the same type.</span></span> <span data-ttu-id="e8f7e-142">例如，如果五个行添加到表三个客户端注册的特定表的表通知，您必须为**Notify**呼叫创建五个**OBJECT_NOTIFICATION**结构。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-142">For example, if three clients are registered for table notification on a particular table and five rows are added to the table, you must create five **OBJECT_NOTIFICATION** structures for your **Notify** call.</span></span> <span data-ttu-id="e8f7e-143">批处理通知如这比调用**Notify**五次更好的性能结果。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-143">A batch notification such as this results in better performance than calling **Notify** five times.</span></span> <span data-ttu-id="e8f7e-144">对于每个**通知**调用，MAPI 调用的每个已注册的通知接收器[IMAPIAdviseSink::OnNotify](imapiadvisesink-onnotify.md)方法。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-144">For each **Notify** call, MAPI calls the [IMAPIAdviseSink::OnNotify](imapiadvisesink-onnotify.md) method of every registered advise sink.</span></span> <span data-ttu-id="e8f7e-145">如果有无注册告知接收器，MAPI 忽略呼叫。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-145">If there are no registered advise sinks, MAPI ignores the call.</span></span> 
  
<span data-ttu-id="e8f7e-146">发送批处理的通知的服务提供商必须订购它们，以便他们可以到最后一解释从第一个通知。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-146">Service providers that send batched notifications must order them so that they can be interpreted from the first notification to the last.</span></span> <span data-ttu-id="e8f7e-147">这种排序时，尤其是必要通知批处理包含一系列事件，如 TABLE_ROW_ADDED 与指的是以前行中的同一批次中的另一个事件已添加的一个事件。</span><span class="sxs-lookup"><span data-stu-id="e8f7e-147">This ordering is especially necessary when a notification batch contains a series of events, such as TABLE_ROW_ADDED with one event that refers to a prior row that was added in another event in the same batch.</span></span>
  
## <a name="see-also"></a><span data-ttu-id="e8f7e-148">另请参阅</span><span class="sxs-lookup"><span data-stu-id="e8f7e-148">See also</span></span>



[<span data-ttu-id="e8f7e-149">MAPI 服务提供商</span><span class="sxs-lookup"><span data-stu-id="e8f7e-149">MAPI Service Providers</span></span>](mapi-service-providers.md)

