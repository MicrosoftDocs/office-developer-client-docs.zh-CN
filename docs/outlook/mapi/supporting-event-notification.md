---
title: 支持事件通知
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: a1e3e49c-8d1d-4f7e-ba5a-be441f0f10ae
description: 上次修改时间：2011 年 7 月 23 日
ms.openlocfilehash: 83c102c25b17b6769c0c676bbadd874224f75cf6
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "32327424"
---
# <a name="supporting-event-notification"></a><span data-ttu-id="7ed47-103">支持事件通知</span><span class="sxs-lookup"><span data-stu-id="7ed47-103">Supporting Event Notification</span></span>

  
  
<span data-ttu-id="7ed47-104">**适用于**：Outlook 2013 | Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="7ed47-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="7ed47-105">由于支持事件通知可能很复杂，MAPI 提供了三种支持对象方法，用于实现该过程的最困难部分。</span><span class="sxs-lookup"><span data-stu-id="7ed47-105">Because supporting event notification can be complicated, MAPI supplies three support object methods that implement the most difficult parts of the process.</span></span> <span data-ttu-id="7ed47-106">这些方法作为一个单元工作，提供程序必须全部使用这三个或全部不使用它们。</span><span class="sxs-lookup"><span data-stu-id="7ed47-106">These methods work as a unit, and a provider must use all three or none of them.</span></span>
  
<span data-ttu-id="7ed47-107">MAPI 支持方法使用通知键管理通知接收器与生成通知的对象之间的连接。</span><span class="sxs-lookup"><span data-stu-id="7ed47-107">The MAPI support methods use notification keys to manage the connections between the advise sinks and the objects that generate the notifications.</span></span> <span data-ttu-id="7ed47-108">通知键是 [一个 NOTIFKEY](notifkey.md) 结构，它包含跨进程标识对象的二进制数据。</span><span class="sxs-lookup"><span data-stu-id="7ed47-108">A notification key is a [NOTIFKEY](notifkey.md) structure that contains binary data that identifies an object across processes.</span></span> <span data-ttu-id="7ed47-109">通知密钥通常从建议源对象的长期条目标识符复制。</span><span class="sxs-lookup"><span data-stu-id="7ed47-109">A notification key is typically copied from the long-term entry identifier of the advise source object.</span></span> <span data-ttu-id="7ed47-110">如果客户端在调用 **Advise** 时提供了条目标识符，可以将它用于通知密钥。</span><span class="sxs-lookup"><span data-stu-id="7ed47-110">If the client has supplied an entry identifier in the call to **Advise**, you can use it for the notification key.</span></span> <span data-ttu-id="7ed47-111">如果 _Advise 的 lpEntryID_ 参数为 NULL，请使用最外部可能容器对象的条目标识符，如邮件存储。 </span><span class="sxs-lookup"><span data-stu-id="7ed47-111">If the  _lpEntryID_ parameter to **Advise** is NULL, use the entry identifier of the outermost possible container object, such as the message store.</span></span> 
  
<span data-ttu-id="7ed47-112">若要使用支持方法，请在客户端调用 **Advise** 方法以注册通知时调用 [IMAPISupport：：Subscribe。](imapisupport-subscribe.md)</span><span class="sxs-lookup"><span data-stu-id="7ed47-112">To use the support methods, call [IMAPISupport::Subscribe](imapisupport-subscribe.md) whenever a client calls your **Advise** method to register for a notification.</span></span> <span data-ttu-id="7ed47-113">分配 [NOTIFKEY](notifkey.md) 结构，并创建建议源对象的唯一通知密钥。</span><span class="sxs-lookup"><span data-stu-id="7ed47-113">Allocate a [NOTIFKEY](notifkey.md) structure and create a unique notification key for your advise source object.</span></span> <span data-ttu-id="7ed47-114">例如，当邮件接收到特定文件夹时提示通知客户端的邮件存储提供程序会为此文件夹创建通知密钥。</span><span class="sxs-lookup"><span data-stu-id="7ed47-114">For example, a message store provider that is prompted to notify a client when a message is received into a particular folder creates a notification key for that folder.</span></span> <span data-ttu-id="7ed47-115">在调用 **Subscribe** 时传递指向 **NOTIFKEY** 结构的指针以及指向客户端的建议接收器的指针。</span><span class="sxs-lookup"><span data-stu-id="7ed47-115">Pass a pointer to the **NOTIFKEY** structure in the call to **Subscribe** along with a pointer to the client's advise sink.</span></span> <span data-ttu-id="7ed47-116">**Subscribe** 调用通知接收器的 [IUnknown：：AddRef](https://msdn.microsoft.com/library/b4316efd-73d4-4995-b898-8025a316ba63%28Office.15%29.aspx) 方法来增加其引用计数，MAPI 将保留指针，直到注册被取消。</span><span class="sxs-lookup"><span data-stu-id="7ed47-116">**Subscribe** calls the advise sink's [IUnknown::AddRef](https://msdn.microsoft.com/library/b4316efd-73d4-4995-b898-8025a316ba63%28Office.15%29.aspx) method to increment its reference count and MAPI retains the pointer until the registration is canceled.</span></span> 
  
<span data-ttu-id="7ed47-117">您可以将 NOTIFY_SYNC 标志传递到 **Subscribe** 以请求 Notify同步方式运行，并且直到它调用了已注册的建议接收器的 [IMAPIAdviseSink：：OnNotify](imapiadvisesink-onnotify.md)方法后才会返回。</span><span class="sxs-lookup"><span data-stu-id="7ed47-117">You can pass the NOTIFY_SYNC flag to **Subscribe** to request that **Notify** behave synchronously and not return until it has made all calls to the [IMAPIAdviseSink::OnNotify](imapiadvisesink-onnotify.md) methods of registered advise sinks.</span></span> <span data-ttu-id="7ed47-118">仅为您自己的内部使用设置此标志。</span><span class="sxs-lookup"><span data-stu-id="7ed47-118">Set this flag only for your own internal use.</span></span> <span data-ttu-id="7ed47-119">在响应客户端 Advise 调用时不要 **设置** 它。</span><span class="sxs-lookup"><span data-stu-id="7ed47-119">Do not set it when you respond to a client **Advise** call.</span></span> <span data-ttu-id="7ed47-120">客户端和提供程序之间的事件通知始终是异步的。</span><span class="sxs-lookup"><span data-stu-id="7ed47-120">Event notification between clients and providers is always asynchronous.</span></span> <span data-ttu-id="7ed47-121">也就是说，MAPI 保证发生事件的调用将在进行任何 **OnNotify** 调用之前返回到客户端。</span><span class="sxs-lookup"><span data-stu-id="7ed47-121">That is, MAPI guarantees that the call during which an event happens will return to the client before any of the **OnNotify** calls are made.</span></span> 
  
<span data-ttu-id="7ed47-122">如果设置 NOTIFY_SYNC 标志，请不要对通知接收器对象的任何更改，并且不要将 [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) 创建的包装器建议接收器传递给 **Subscribe**。</span><span class="sxs-lookup"><span data-stu-id="7ed47-122">If you set the NOTIFY_SYNC flag, do not make any changes to any of the advise sink objects, and do not pass a wrapper advise sink created by [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) to **Subscribe**.</span></span> <span data-ttu-id="7ed47-123">**HrThisThreadAdviseSink** 创建建议接收器的线程安全版本，以仅用于异步通知。</span><span class="sxs-lookup"><span data-stu-id="7ed47-123">**HrThisThreadAdviseSink** creates a thread-safe version of an advise sink to be used with asynchronous notification only.</span></span> 
  
<span data-ttu-id="7ed47-124">如果注册为同步通知的通知接收器从设置了 CALLBACK_DISCONTINUE 标志的 **OnNotify** 返回， [则 IMAPISupport：：Notify](imapisupport-notify.md) 将设置 NOTIFY_CANCELED 标志并返回，而不对 **OnNotify** 进行任何调用。</span><span class="sxs-lookup"><span data-stu-id="7ed47-124">If an advise sink registered for synchronous notification returns from **OnNotify** with the CALLBACK_DISCONTINUE flag set, [IMAPISupport::Notify](imapisupport-notify.md) sets the NOTIFY_CANCELED flag and returns without making any calls to **OnNotify**.</span></span> 
  
<span data-ttu-id="7ed47-125">一 **旦** Subscribe 返回，你将不再需要保留客户端建议接收器的副本。</span><span class="sxs-lookup"><span data-stu-id="7ed47-125">Once **Subscribe** has returned, you will no longer have any need to hold onto your copy of the client's advise sink.</span></span> <span data-ttu-id="7ed47-126">调用其 [IUnknown：：Release](https://msdn.microsoft.com/library/4b494c6f-f0ee-4c35-ae45-ed956f40dc7a%28Office.15%29.aspx) 方法以释放它。</span><span class="sxs-lookup"><span data-stu-id="7ed47-126">Call its [IUnknown::Release](https://msdn.microsoft.com/library/4b494c6f-f0ee-4c35-ae45-ed956f40dc7a%28Office.15%29.aspx) method to release it.</span></span> <span data-ttu-id="7ed47-127">**Subscribe** 返回一个非零连接号，您应返回到客户端。</span><span class="sxs-lookup"><span data-stu-id="7ed47-127">**Subscribe** returns a nonzero connection number that you should return to the client.</span></span> <span data-ttu-id="7ed47-128">连接号代表建议源与建议接收器之间的链接。</span><span class="sxs-lookup"><span data-stu-id="7ed47-128">The connection number represents the link between the advise source and the advise sink.</span></span> <span data-ttu-id="7ed47-129">在客户端成功调用 **Unadvise 之前，它一直有效**。</span><span class="sxs-lookup"><span data-stu-id="7ed47-129">It remains valid until the client makes a successful call to **Unadvise**.</span></span> 
  
<span data-ttu-id="7ed47-130">当客户端准备取消注册时，它将调用 **您的 Unadvise** 方法。</span><span class="sxs-lookup"><span data-stu-id="7ed47-130">When the client is ready to cancel a registration, it calls your **Unadvise** method.</span></span> <span data-ttu-id="7ed47-131">将连接号从 **Unadvise** 调用传递到 [IMAPISupport：：Unsubscribe](imapisupport-unsubscribe.md)。</span><span class="sxs-lookup"><span data-stu-id="7ed47-131">Pass the connection number from the **Unadvise** call to [IMAPISupport::Unsubscribe](imapisupport-unsubscribe.md).</span></span> <span data-ttu-id="7ed47-132">**Unsubscribe** 调用通知接收器的 **IUnknown：：Release** 方法。</span><span class="sxs-lookup"><span data-stu-id="7ed47-132">**Unsubscribe** calls the advise sink's **IUnknown::Release** method.</span></span> <span data-ttu-id="7ed47-133">与 **"建议"** 和" **取消订阅**"一样，对 **"订阅** "和 **"取消订阅** "的调用必须配对。</span><span class="sxs-lookup"><span data-stu-id="7ed47-133">As with **Advise** and **Unadvise**, calls to **Subscribe** and **Unsubscribe** must be paired.</span></span> <span data-ttu-id="7ed47-134">对于对 Subscribe 进行的每一次调用，都必须对 **"** 取消订阅 **"进行一次调用**。</span><span class="sxs-lookup"><span data-stu-id="7ed47-134">You must make one call to **Unsubscribe** for every call that is made to **Subscribe**.</span></span> <span data-ttu-id="7ed47-135">但是，每次调用 **Advise** 方法时，都不需要调用 **Subscribe。**</span><span class="sxs-lookup"><span data-stu-id="7ed47-135">However, you do not have to call **Subscribe** every time your **Advise** method is called.</span></span> <span data-ttu-id="7ed47-136">相反，您可以调用它来设置内部通知。</span><span class="sxs-lookup"><span data-stu-id="7ed47-136">Conversely, you can call it for setting up internal notifications.</span></span> 
  
<span data-ttu-id="7ed47-137">当事件发生时，分配适用于事件的类型的一个或多个 [NOTIFICATION](notification.md) 结构，并调用 [IMAPISupport：：Notify](imapisupport-notify.md)。</span><span class="sxs-lookup"><span data-stu-id="7ed47-137">When an event occurs, allocate one or more [NOTIFICATION](notification.md) structures of the type appropriate for the event and call [IMAPISupport::Notify](imapisupport-notify.md).</span></span> <span data-ttu-id="7ed47-138">**Notify** 会针对每个注册的通知接收器生成一个通知。</span><span class="sxs-lookup"><span data-stu-id="7ed47-138">**Notify** generates a notification for each registered advise sink.</span></span> <span data-ttu-id="7ed47-139">应该将 [NOTIFICATION](notification.md) 结构的所有未使用的成员设置为零。</span><span class="sxs-lookup"><span data-stu-id="7ed47-139">You should set all the unused members of the [NOTIFICATION](notification.md) structure to zero.</span></span> <span data-ttu-id="7ed47-140">这种初始化 **NOTIFICATION** 结构的技术可帮助客户端创建更小、更快、更不容易出错的 **OnNotify** 实现。</span><span class="sxs-lookup"><span data-stu-id="7ed47-140">This technique for initializing the **NOTIFICATION** structure can help clients create smaller, faster, and less error-prone **OnNotify** implementations.</span></span> 
  
<span data-ttu-id="7ed47-141">请注意，每个事件需要单独的 **NOTIFICATION** 结构，即使对于同一类型的多个事件也是必需的。</span><span class="sxs-lookup"><span data-stu-id="7ed47-141">Note that a separate **NOTIFICATION** structure is necessary for each event, even for multiple events of the same type.</span></span> <span data-ttu-id="7ed47-142">例如，如果为特定表上的表通知注册了三个客户端，并且向表中添加了五行，则必须为 **Notify** 调用创建 **五** OBJECT_NOTIFICATION通知结构。</span><span class="sxs-lookup"><span data-stu-id="7ed47-142">For example, if three clients are registered for table notification on a particular table and five rows are added to the table, you must create five **OBJECT_NOTIFICATION** structures for your **Notify** call.</span></span> <span data-ttu-id="7ed47-143">与调用通知五次时类似这样的批通知可 **提高性能** 。</span><span class="sxs-lookup"><span data-stu-id="7ed47-143">A batch notification such as this results in better performance than calling **Notify** five times.</span></span> <span data-ttu-id="7ed47-144">对于每个 **Notify** 调用，MAPI 将调用每个注册的建议接收器的 [IMAPIAdviseSink：：OnNotify](imapiadvisesink-onnotify.md) 方法。</span><span class="sxs-lookup"><span data-stu-id="7ed47-144">For each **Notify** call, MAPI calls the [IMAPIAdviseSink::OnNotify](imapiadvisesink-onnotify.md) method of every registered advise sink.</span></span> <span data-ttu-id="7ed47-145">如果没有注册的建议接收器，MAPI 将忽略调用。</span><span class="sxs-lookup"><span data-stu-id="7ed47-145">If there are no registered advise sinks, MAPI ignores the call.</span></span> 
  
<span data-ttu-id="7ed47-146">发送批处理通知的服务提供商必须对它们排序，以便可以从第一个通知解释为最后一个通知。</span><span class="sxs-lookup"><span data-stu-id="7ed47-146">Service providers that send batched notifications must order them so that they can be interpreted from the first notification to the last.</span></span> <span data-ttu-id="7ed47-147">当通知批处理包含一系列事件（如 TABLE_ROW_ADDED，其中一个事件引用了同一批次中的另一个事件中添加的上一行）时，此排序尤为必要。</span><span class="sxs-lookup"><span data-stu-id="7ed47-147">This ordering is especially necessary when a notification batch contains a series of events, such as TABLE_ROW_ADDED with one event that refers to a prior row that was added in another event in the same batch.</span></span>
  
## <a name="see-also"></a><span data-ttu-id="7ed47-148">另请参阅</span><span class="sxs-lookup"><span data-stu-id="7ed47-148">See also</span></span>



[<span data-ttu-id="7ed47-149">MAPI 服务提供程序</span><span class="sxs-lookup"><span data-stu-id="7ed47-149">MAPI Service Providers</span></span>](mapi-service-providers.md)

