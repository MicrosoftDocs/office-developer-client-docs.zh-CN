---
title: MAPI 中的结构化存储
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 642a678b-4bf2-4246-85cb-c798de23e36f
description: 上次修改时间：2015 年 3 月 9 日
ms.openlocfilehash: f58fa70e98841db5507323a63737f1df6c1b7a6d
ms.sourcegitcommit: 8657170d071f9bcf680aba50b9c07f2a4fb82283
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/28/2019
ms.locfileid: "33411748"
---
# <a name="structured-storage-in-mapi"></a><span data-ttu-id="91fd2-103">MAPI 中的结构化存储</span><span class="sxs-lookup"><span data-stu-id="91fd2-103">Structured Storage in MAPI</span></span>

  
  
<span data-ttu-id="91fd2-104">**适用于**：Outlook 2013 | Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="91fd2-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="91fd2-105">结构化存储指随 COM 引入的存储的分层组织。</span><span class="sxs-lookup"><span data-stu-id="91fd2-105">Structured storage refers to the hierarchical organization of storage introduced with COM.</span></span> <span data-ttu-id="91fd2-106">在结构化存储环境中, 将存储组织为两种或三种类型的对象:</span><span class="sxs-lookup"><span data-stu-id="91fd2-106">In a structured storage environment, storage is organized into two or three types of objects:</span></span> 
  
- <span data-ttu-id="91fd2-107">Stream 对象</span><span class="sxs-lookup"><span data-stu-id="91fd2-107">Stream objects</span></span>
    
- <span data-ttu-id="91fd2-108">锁定字节对象</span><span class="sxs-lookup"><span data-stu-id="91fd2-108">Lock bytes objects</span></span>
    
- <span data-ttu-id="91fd2-109">存储对象</span><span class="sxs-lookup"><span data-stu-id="91fd2-109">Storage objects</span></span>
    
<span data-ttu-id="91fd2-110">流和锁定字节是可直接访问数据的较低级别对象。</span><span class="sxs-lookup"><span data-stu-id="91fd2-110">Stream and lock bytes are lower-level objects that directly access the data.</span></span> <span data-ttu-id="91fd2-111">Stream 对象实现**IStream**接口, 该接口定义用于读取、写入、定位和复制数据字节的方法。</span><span class="sxs-lookup"><span data-stu-id="91fd2-111">Stream objects implement the **IStream** interface which defines methods for reading, writing, positioning, and copying bytes of data.</span></span> <span data-ttu-id="91fd2-112">Lock bytes 对象实现另一个 COM 接口**ILockBytes**, 以使用字节数组访问数据。</span><span class="sxs-lookup"><span data-stu-id="91fd2-112">Lock bytes objects implement another COM interface, **ILockBytes**, to access data with a byte array.</span></span> <span data-ttu-id="91fd2-113">字节数组通常用于提供对基础存储的自定义访问。</span><span class="sxs-lookup"><span data-stu-id="91fd2-113">Byte arrays are typically used to provide customized access to underlying storage.</span></span>
  
<span data-ttu-id="91fd2-114">存储对象在 stream 或 lock bytes 对象的上方分层;它们可以包含一个或多个这些对象以及其他存储对象。</span><span class="sxs-lookup"><span data-stu-id="91fd2-114">Storage objects are layered on top of the stream or lock bytes objects; they can contain one or more of these objects as well as other storage objects.</span></span> <span data-ttu-id="91fd2-115">Storage 对象实现**IStorage**接口, 该接口定义用于创建、访问和维护嵌套对象的方法。</span><span class="sxs-lookup"><span data-stu-id="91fd2-115">Storage objects implement the **IStorage** interface which defines methods for creating, accessing, and maintaining nested objects.</span></span> 
  
<span data-ttu-id="91fd2-116">由于**IStream**、 **ILockBytes**和**IStorage**是 com 接口而不是 mapi 接口, 因此它们的方法返回 com 错误值而不是 mapi 值。</span><span class="sxs-lookup"><span data-stu-id="91fd2-116">Because **IStream**, **ILockBytes**, and **IStorage** are COM interfaces rather than MAPI interfaces, their methods return COM error values rather than MAPI values.</span></span> <span data-ttu-id="91fd2-117">客户端和服务提供程序调用这些接口中的方法时, 必须使用 API 函数**MapStorageSCode**将这些值转换为 MAPI 错误值。</span><span class="sxs-lookup"><span data-stu-id="91fd2-117">Clients and service providers calling methods in these interfaces must use the API function **MapStorageSCode** to translate these values into MAPI error values.</span></span> <span data-ttu-id="91fd2-118">有关详细信息, 请参阅[MapStorageSCode](mapstoragescode.md)。</span><span class="sxs-lookup"><span data-stu-id="91fd2-118">For more information, see [MapStorageSCode](mapstoragescode.md).</span></span>
  
<span data-ttu-id="91fd2-119">客户端和服务提供程序使用结构化存储来处理因过大而无法使用**IMAPIProp**方法维护的属性, 通常是大型字符串和二进制属性。</span><span class="sxs-lookup"><span data-stu-id="91fd2-119">Clients and service providers use structured storage for working with properties that are too large to maintain with the **IMAPIProp** methods, typically large string and binary properties.</span></span> <span data-ttu-id="91fd2-120">客户端或服务提供程序访问它们的常用方法之一是, 在对[IMAPIProp:: OpenProperty](imapiprop-openproperty.md)方法的调用中将**IStream**或**IStorage**指定为接口标识符。</span><span class="sxs-lookup"><span data-stu-id="91fd2-120">One of the common ways that clients or service providers access them is by specifying **IStream** or **IStorage** as the interface identifier in a call to the [IMAPIProp::OpenProperty](imapiprop-openproperty.md) method.</span></span> <span data-ttu-id="91fd2-121">例如, 客户端将**PR_ATTACH_DATA_BIN**作为属性标记, 并将 IID_IStream 作为接口标识符调用, 以访问邮件中的二进制附件的**OpenProperty** 。</span><span class="sxs-lookup"><span data-stu-id="91fd2-121">For example, clients call **OpenProperty** with **PR_ATTACH_DATA_BIN** as the property tag and IID_IStream as the interface identifier to access a binary attachment in a message.</span></span> 
  
<span data-ttu-id="91fd2-122">客户端和服务提供程序可以实现自己的 stream 和 storage 对象或调用 API 函数, 以访问 MAPI 或 COM 提供的实现。</span><span class="sxs-lookup"><span data-stu-id="91fd2-122">Clients and service providers can implement their own stream and storage objects or call API functions to access implementations supplied by MAPI or COM.</span></span> <span data-ttu-id="91fd2-123">由于提供的实现为大多数目的提供服务, 因此客户端和服务提供程序很少需要创建自己的实现。</span><span class="sxs-lookup"><span data-stu-id="91fd2-123">Because the supplied implementations serve most purposes, clients and service providers rarely need to create their own.</span></span> 
  
<span data-ttu-id="91fd2-124">当客户端对 MAPI 对象调用**OpenProperty**以通过存储对象访问其属性之一时, 服务提供程序通常会在直接模式下打开存储对象。</span><span class="sxs-lookup"><span data-stu-id="91fd2-124">When a client calls **OpenProperty** on a MAPI object to access one of its properties through a storage object, the service provider will typically open the storage object in direct mode.</span></span> <span data-ttu-id="91fd2-125">但是, 这是典型行为, 而不是必需的行为。</span><span class="sxs-lookup"><span data-stu-id="91fd2-125">However, this is typical rather than required behavior.</span></span> <span data-ttu-id="91fd2-126">客户端应假定服务提供程序打开或创建的所有存储对象都进行了事务处理, 并且需要调用**IStorage:: Commit**。</span><span class="sxs-lookup"><span data-stu-id="91fd2-126">Clients should assume that all storage objects opened or created by service providers are transacted and require a call to **IStorage::Commit**.</span></span> <span data-ttu-id="91fd2-127">此外, 还应注意, 对存储对象所做的更改在其调用**IMAPIProp:: SaveChanges**之后将不会\*\*\*\* 永久生效, 以保存 MAPI 对象。</span><span class="sxs-lookup"><span data-stu-id="91fd2-127">They should also remember that changes to storage objects will not be made permanent until they call **IMAPIProp::SaveChanges** after the final **Commit** to save the MAPI object.</span></span> <span data-ttu-id="91fd2-128">有关详细信息, 请参阅[IMAPIProp:: SaveChanges](imapiprop-savechanges.md)。</span><span class="sxs-lookup"><span data-stu-id="91fd2-128">For more information, see [IMAPIProp::SaveChanges](imapiprop-savechanges.md).</span></span>
  
<span data-ttu-id="91fd2-129">MAPI 和 COM 提供了用于定义或访问存储和流对象的几个 API 函数。</span><span class="sxs-lookup"><span data-stu-id="91fd2-129">MAPI and COM provide several API functions for defining or accessing storage and stream objects.</span></span> <span data-ttu-id="91fd2-130">下表描述了常用函数。</span><span class="sxs-lookup"><span data-stu-id="91fd2-130">The commonly used functions are described in the following table.</span></span>
  
<span data-ttu-id="91fd2-131">**用于访问存储和 Stream 对象的函数**</span><span class="sxs-lookup"><span data-stu-id="91fd2-131">**Functions for Accessing Storage and Stream Objects**</span></span>

|<span data-ttu-id="91fd2-132">**函数**</span><span class="sxs-lookup"><span data-stu-id="91fd2-132">**Function**</span></span>|<span data-ttu-id="91fd2-133">**说明**</span><span class="sxs-lookup"><span data-stu-id="91fd2-133">**Description**</span></span>|
|:-----|:-----|
|[<span data-ttu-id="91fd2-134">HrIStorageFromStream</span><span class="sxs-lookup"><span data-stu-id="91fd2-134">HrIStorageFromStream</span></span>](hristoragefromstream.md) <br/> |<span data-ttu-id="91fd2-135">创建存储对象以访问 stream 或 lock bytes 对象。</span><span class="sxs-lookup"><span data-stu-id="91fd2-135">Creates a storage object to access a stream or lock bytes object.</span></span>  <br/> |
|[<span data-ttu-id="91fd2-136">OpenIMsgOnIStg</span><span class="sxs-lookup"><span data-stu-id="91fd2-136">OpenIMsgOnIStg</span></span>](openimsgonistg.md) <br/> |<span data-ttu-id="91fd2-137">创建一个 message 对象以访问存储对象。</span><span class="sxs-lookup"><span data-stu-id="91fd2-137">Creates a message object to access a storage object.</span></span>  <br/> |
|[<span data-ttu-id="91fd2-138">OpenStreamOnFile</span><span class="sxs-lookup"><span data-stu-id="91fd2-138">OpenStreamOnFile</span></span>](openstreamonfile.md) <br/> |<span data-ttu-id="91fd2-139">创建 stream 对象以访问文件。</span><span class="sxs-lookup"><span data-stu-id="91fd2-139">Creates a stream object to access a file.</span></span>  <br/> |
|[<span data-ttu-id="91fd2-140">WrapCompressedRTFStream</span><span class="sxs-lookup"><span data-stu-id="91fd2-140">WrapCompressedRTFStream</span></span>](wrapcompressedrtfstream.md) <br/> |<span data-ttu-id="91fd2-141">创建一个 stream 对象, 该对象包含包含邮件的格式文本的流的压缩版本或未压缩版本。</span><span class="sxs-lookup"><span data-stu-id="91fd2-141">Creates a stream object that contains the compressed or uncompressed version of a stream holding the rich text of a message.</span></span>  <br/> |
   
 <span data-ttu-id="91fd2-142">**检索给定 substorage 中的流的名称**</span><span class="sxs-lookup"><span data-stu-id="91fd2-142">**To retrieve the names of the streams in a given substorage**</span></span>
  
1. <span data-ttu-id="91fd2-143">调用 substorage 的**IStorage:: EnumElements**方法以获取**IEnumSTATSTG**接口。</span><span class="sxs-lookup"><span data-stu-id="91fd2-143">Call the substorage's **IStorage::EnumElements** method to get an **IEnumSTATSTG** interface.</span></span> 
    
2. <span data-ttu-id="91fd2-144">**IEnumSTATSTG:: 下一**次使用任意数量的**STATSTG**结构的调用。</span><span class="sxs-lookup"><span data-stu-id="91fd2-144">Call **IEnumSTATSTG::Next** with as many **STATSTG** structures at a time as you can.</span></span> <span data-ttu-id="91fd2-145">[! 注意] 如果一次请求 100, 则**Next**通常会返回 S_FALSE, 并将_pceltFetched_的内容设置为实际检索的编号。</span><span class="sxs-lookup"><span data-stu-id="91fd2-145">If you ask for 100 at a time, **Next** will usually return S_FALSE with the contents of  _pceltFetched_ set to the number that were actually retrieved.</span></span> 
    
3. <span data-ttu-id="91fd2-146">检查使用 STGTY_STREAM 标记的**STATSTG**结构。</span><span class="sxs-lookup"><span data-stu-id="91fd2-146">Check for the **STATSTG** structures that are flagged with STGTY_STREAM.</span></span> 
    
4. <span data-ttu-id="91fd2-147">释放_pwcsName_参数。</span><span class="sxs-lookup"><span data-stu-id="91fd2-147">Release the  _pwcsName_ parameter.</span></span> 
    
 <span data-ttu-id="91fd2-148">**创建存储对象以访问现有的 stream 或 lock bytes 对象**</span><span class="sxs-lookup"><span data-stu-id="91fd2-148">**To create a storage object to access an existing stream or lock bytes object**</span></span>
  
- <span data-ttu-id="91fd2-149">客户端调用[HrIStorageFromStream](hristoragefromstream.md)。</span><span class="sxs-lookup"><span data-stu-id="91fd2-149">Clients call [HrIStorageFromStream](hristoragefromstream.md).</span></span> 
    
 <span data-ttu-id="91fd2-150">**创建邮件对象以访问现有存储对象**</span><span class="sxs-lookup"><span data-stu-id="91fd2-150">**To create a message object to access an existing storage object**</span></span>
  
- <span data-ttu-id="91fd2-151">服务提供商和客户端调用[OpenIMsgOnIStg](openimsgonistg.md)。</span><span class="sxs-lookup"><span data-stu-id="91fd2-151">Service providers and clients call [OpenIMsgOnIStg](openimsgonistg.md).</span></span> <span data-ttu-id="91fd2-152">创建的 message 对象不同于通常由邮件存储提供程序创建的邮件对象, 因为它不支持所有[IMessage: IMAPIProp](imessageimapiprop.md)接口方法, 如**IMessage:: SubmitMessage**。</span><span class="sxs-lookup"><span data-stu-id="91fd2-152">The message object that is created differs from the message objects typically created by message store providers in that it does not support all of the [IMessage : IMAPIProp](imessageimapiprop.md) interface methods, such as **IMessage::SubmitMessage**.</span></span> <span data-ttu-id="91fd2-153">**OpenIMsgOnIStg**的可选输入参数是符合[MSGCALLRELEASE](msgcallrelease.md)原型的回调函数。</span><span class="sxs-lookup"><span data-stu-id="91fd2-153">An optional input parameter to **OpenIMsgOnIStg** is a callback function that conforms to the [MSGCALLRELEASE](msgcallrelease.md) prototype.</span></span> <span data-ttu-id="91fd2-154">当邮件的引用计数达到零时, 新的 message 对象调用此函数。</span><span class="sxs-lookup"><span data-stu-id="91fd2-154">This function is called by the new message object when the message's reference count reaches zero.</span></span> <span data-ttu-id="91fd2-155">在完全删除新邮件之前, 实现**MSGCALLRELEASE**函数可用于执行最终处理。</span><span class="sxs-lookup"><span data-stu-id="91fd2-155">Implementing a **MSGCALLRELEASE** function can be useful for performing final processing before the new message is completely removed.</span></span> 
    
<span data-ttu-id="91fd2-156">[OpenStreamOnFile](openstreamonfile.md)通常用于存储文件附件, 因为它会创建一个从文件中读取和写入文件的流。</span><span class="sxs-lookup"><span data-stu-id="91fd2-156">[OpenStreamOnFile](openstreamonfile.md) is commonly used for storing file attachments because it creates a stream that reads from and writes to a file.</span></span> <span data-ttu-id="91fd2-157">**OpenProperty** with **PR_ATTACH_DATA_BIN**作为属性标记创建用于存储二进制附件数据的流。</span><span class="sxs-lookup"><span data-stu-id="91fd2-157">**OpenProperty** with **PR_ATTACH_DATA_BIN** as the property tag creates a stream for storing binary attachment data.</span></span> 
  
 <span data-ttu-id="91fd2-158">**压缩或解压缩包含 rtf 格式的邮件文本的流**</span><span class="sxs-lookup"><span data-stu-id="91fd2-158">**To compress or uncompress a stream containing message text in the Rich Text Format**</span></span>
  
- <span data-ttu-id="91fd2-159">客户端调用[WrapCompressedRTFStream](wrapcompressedrtfstream.md)。</span><span class="sxs-lookup"><span data-stu-id="91fd2-159">Clients call [WrapCompressedRTFStream](wrapcompressedrtfstream.md).</span></span> <span data-ttu-id="91fd2-160">**WrapCompressedRTFStream**创建一个包装 RTF 流的流。</span><span class="sxs-lookup"><span data-stu-id="91fd2-160">**WrapCompressedRTFStream** creates a stream that wraps the RTF stream.</span></span> <span data-ttu-id="91fd2-161">包装流不实现所有的**IStream**方法;排除了以下方法: **Seek**、 **SetSize**、 **Revert**、 **LockRegion**、 **UnlockRegion**、 **Stat**和**Clone**。</span><span class="sxs-lookup"><span data-stu-id="91fd2-161">The wrapper stream does not implement all of the **IStream** methods; the following methods are excluded: **Seek**, **SetSize**, **Revert**, **LockRegion**, **UnlockRegion**, **Stat**, and **Clone**.</span></span> <span data-ttu-id="91fd2-162">这是因为**WrapCompressedRTFStream**创建的 stream 对象不支持**SetSize**或**Stat**, 不是扩展或检索其大小的简单方法。</span><span class="sxs-lookup"><span data-stu-id="91fd2-162">This is because the stream objects created by **WrapCompressedRTFStream** do not support either **SetSize** or **Stat**, there is not an easy way to either extend or retrieve their size.</span></span> <span data-ttu-id="91fd2-163">最佳策略是选择合理的缓冲区大小, 并在循环中进行读取或写入。</span><span class="sxs-lookup"><span data-stu-id="91fd2-163">The best strategy is to pick a reasonable buffer size and read or write in a loop.</span></span>
    
> [!NOTE]
> <span data-ttu-id="91fd2-164">COM 具有一个基于字节数组的存储对象实现, 该数组从有问题的**EnumElements**方法返回一个**IEnumSTATSTG**对象。</span><span class="sxs-lookup"><span data-stu-id="91fd2-164">COM has a storage object implementation based on a byte array that returns an **IEnumSTATSTG** object from the **EnumElements** method that is problematic.</span></span> <span data-ttu-id="91fd2-165">具体说来, **QueryInterface**方法无法正常工作。</span><span class="sxs-lookup"><span data-stu-id="91fd2-165">In particular, the **QueryInterface** method does not work correctly.</span></span> <span data-ttu-id="91fd2-166">使用 COM 实现来实现其自己的存储对象的服务提供程序应为**IEnumSTATSTG**对象创建一个瘦包装, 该包装会将呼叫转发到基础**IEnumSTATSTG**方法, 但却实现了自己的**AddRef**、 **Release**、 **QueryInterface**和**Clone**方法。</span><span class="sxs-lookup"><span data-stu-id="91fd2-166">Service providers that implement their own storage objects using the COM implementation should create a thin wrapper for the **IEnumSTATSTG** object that forwards calls on to the underlying **IEnumSTATSTG** methods but implements its own **AddRef**, **Release**, **QueryInterface**, and **Clone** methods.</span></span> 
  

