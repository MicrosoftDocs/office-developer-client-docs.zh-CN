---
title: MAPI 中的结构化的存储
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 642a678b-4bf2-4246-85cb-c798de23e36f
description: 上次修改时间：2015 年 3 月 9 日
ms.openlocfilehash: 462ee84d5e9acd26f80bae6516179f21651749be
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/11/2018
ms.locfileid: "19778910"
---
# <a name="structured-storage-in-mapi"></a><span data-ttu-id="ad15e-103">MAPI 中的结构化的存储</span><span class="sxs-lookup"><span data-stu-id="ad15e-103">Structured Storage in MAPI</span></span>

  
  
<span data-ttu-id="ad15e-104">**适用于**： Outlook</span><span class="sxs-lookup"><span data-stu-id="ad15e-104">**Applies to**: Outlook</span></span> 
  
<span data-ttu-id="ad15e-105">结构化的存储是指存储 COM.中引入的分层组织</span><span class="sxs-lookup"><span data-stu-id="ad15e-105">Structured storage refers to the hierarchical organization of storage introduced with COM.</span></span> <span data-ttu-id="ad15e-106">结构化的存储环境中存储分为两个或三种类型的对象：</span><span class="sxs-lookup"><span data-stu-id="ad15e-106">In a structured storage environment, storage is organized into two or three types of objects:</span></span> 
  
- <span data-ttu-id="ad15e-107">Stream 对象</span><span class="sxs-lookup"><span data-stu-id="ad15e-107">Stream objects</span></span>
    
- <span data-ttu-id="ad15e-108">锁定字节对象</span><span class="sxs-lookup"><span data-stu-id="ad15e-108">Lock bytes objects</span></span>
    
- <span data-ttu-id="ad15e-109">存储对象</span><span class="sxs-lookup"><span data-stu-id="ad15e-109">Storage objects</span></span>
    
<span data-ttu-id="ad15e-110">流和锁定字节是直接访问的数据的级别较低的对象。</span><span class="sxs-lookup"><span data-stu-id="ad15e-110">Stream and lock bytes are lower-level objects that directly access the data.</span></span> <span data-ttu-id="ad15e-111">Stream 对象实现**IStream**接口它定义用于读取、 写入、 定位、 和复制字节的数据的方法。</span><span class="sxs-lookup"><span data-stu-id="ad15e-111">Stream objects implement the **IStream** interface which defines methods for reading, writing, positioning, and copying bytes of data.</span></span> <span data-ttu-id="ad15e-112">锁定字节对象实现其他 COM 接口， **ILockBytes**，若要访问与一个字节数组的数据。</span><span class="sxs-lookup"><span data-stu-id="ad15e-112">Lock bytes objects implement another COM interface, **ILockBytes**, to access data with a byte array.</span></span> <span data-ttu-id="ad15e-113">通常，用于字节数组，以提供对基础存储的自定义的访问。</span><span class="sxs-lookup"><span data-stu-id="ad15e-113">Byte arrays are typically used to provide customized access to underlying storage.</span></span>
  
<span data-ttu-id="ad15e-114">存储对象层叠流或锁定字节对象;它们可以包含一个或多个这些对象以及其他存储对象。</span><span class="sxs-lookup"><span data-stu-id="ad15e-114">Storage objects are layered on top of the stream or lock bytes objects; they can contain one or more of these objects as well as other storage objects.</span></span> <span data-ttu-id="ad15e-115">存储对象实现**IStorage**接口它定义用于创建、 访问和维护嵌套的对象的方法。</span><span class="sxs-lookup"><span data-stu-id="ad15e-115">Storage objects implement the **IStorage** interface which defines methods for creating, accessing, and maintaining nested objects.</span></span> 
  
<span data-ttu-id="ad15e-116">由于**IStream**、 **ILockBytes**和**IStorage** COM 接口，而不是 MAPI 接口，其方法将返回 COM 错误值而不是 MAPI 值。</span><span class="sxs-lookup"><span data-stu-id="ad15e-116">Because **IStream**, **ILockBytes**, and **IStorage** are COM interfaces rather than MAPI interfaces, their methods return COM error values rather than MAPI values.</span></span> <span data-ttu-id="ad15e-117">客户端和这些接口中调用方法的服务提供商必须使用 API 函数**MapStorageSCode**将这些值转换 MAPI 错误值。</span><span class="sxs-lookup"><span data-stu-id="ad15e-117">Clients and service providers calling methods in these interfaces must use the API function **MapStorageSCode** to translate these values into MAPI error values.</span></span> <span data-ttu-id="ad15e-118">有关详细信息，请参阅[MapStorageSCode](mapstoragescode.md)。</span><span class="sxs-lookup"><span data-stu-id="ad15e-118">For more information, see [MapStorageSCode](mapstoragescode.md).</span></span>
  
<span data-ttu-id="ad15e-119">客户端和服务提供商可以用于结构化的存储使用太长维护**IMAPIProp**方法、 通常较大字符串和二进制属性的属性。</span><span class="sxs-lookup"><span data-stu-id="ad15e-119">Clients and service providers use structured storage for working with properties that are too large to maintain with the **IMAPIProp** methods, typically large string and binary properties.</span></span> <span data-ttu-id="ad15e-120">客户端或服务提供商访问它们的常用方法之一是通过作为对[IMAPIProp::OpenProperty](imapiprop-openproperty.md)方法的调用中的接口标识符指定**IStream**或**IStorage** 。</span><span class="sxs-lookup"><span data-stu-id="ad15e-120">One of the common ways that clients or service providers access them is by specifying **IStream** or **IStorage** as the interface identifier in a call to the [IMAPIProp::OpenProperty](imapiprop-openproperty.md) method.</span></span> <span data-ttu-id="ad15e-121">例如，客户端调用与**PR_ATTACH_DATA_BIN** **OpenProperty**作为属性标记和接口标识 IID_IStream 访问邮件中的二进制附件。</span><span class="sxs-lookup"><span data-stu-id="ad15e-121">For example, clients call **OpenProperty** with **PR_ATTACH_DATA_BIN** as the property tag and IID_IStream as the interface identifier to access a binary attachment in a message.</span></span> 
  
<span data-ttu-id="ad15e-122">客户端和服务提供商可以实现自己流和存储的对象或调用访问实现 MAPI 或 COM.提供的 API 函数</span><span class="sxs-lookup"><span data-stu-id="ad15e-122">Clients and service providers can implement their own stream and storage objects or call API functions to access implementations supplied by MAPI or COM.</span></span> <span data-ttu-id="ad15e-123">因为提供的实现有大多数情况下，客户端和服务提供商很少需要创建自己。</span><span class="sxs-lookup"><span data-stu-id="ad15e-123">Because the supplied implementations serve most purposes, clients and service providers rarely need to create their own.</span></span> 
  
<span data-ttu-id="ad15e-124">当客户端调用**OpenProperty** MAPI 对象上存储对象通过访问其属性之一时，服务提供程序通常将在直接模式中打开的存储对象。</span><span class="sxs-lookup"><span data-stu-id="ad15e-124">When a client calls **OpenProperty** on a MAPI object to access one of its properties through a storage object, the service provider will typically open the storage object in direct mode.</span></span> <span data-ttu-id="ad15e-125">但是，这是典型而不是所需行为。</span><span class="sxs-lookup"><span data-stu-id="ad15e-125">However, this is typical rather than required behavior.</span></span> <span data-ttu-id="ad15e-126">客户端应假定打开或创建由服务提供商提供的所有存储对象的事务处理，并需要**IStorage::Commit**调用。</span><span class="sxs-lookup"><span data-stu-id="ad15e-126">Clients should assume that all storage objects opened or created by service providers are transacted and require a call to **IStorage::Commit**.</span></span> <span data-ttu-id="ad15e-127">他们还应该记住存储对象更改将不进行永久他们最后一**提交**保存 MAPI 对象之后调用**IMAPIProp::SaveChanges**之前。</span><span class="sxs-lookup"><span data-stu-id="ad15e-127">They should also remember that changes to storage objects will not be made permanent until they call **IMAPIProp::SaveChanges** after the final **Commit** to save the MAPI object.</span></span> <span data-ttu-id="ad15e-128">有关详细信息，请参阅[IMAPIProp::SaveChanges](imapiprop-savechanges.md)。</span><span class="sxs-lookup"><span data-stu-id="ad15e-128">For more information, see [IMAPIProp::SaveChanges](imapiprop-savechanges.md).</span></span>
  
<span data-ttu-id="ad15e-129">MAPI 和 COM 提供用于定义或访问存储和 stream 对象的几个 API 函数。</span><span class="sxs-lookup"><span data-stu-id="ad15e-129">MAPI and COM provide several API functions for defining or accessing storage and stream objects.</span></span> <span data-ttu-id="ad15e-130">下表中介绍的常用的功能。</span><span class="sxs-lookup"><span data-stu-id="ad15e-130">The commonly used functions are described in the following table.</span></span>
  
<span data-ttu-id="ad15e-131">**用于访问存储和 Stream 对象的函数**</span><span class="sxs-lookup"><span data-stu-id="ad15e-131">**Functions for Accessing Storage and Stream Objects**</span></span>

|<span data-ttu-id="ad15e-132">**函数**</span><span class="sxs-lookup"><span data-stu-id="ad15e-132">**Function**</span></span>|<span data-ttu-id="ad15e-133">**说明**</span><span class="sxs-lookup"><span data-stu-id="ad15e-133">**Description**</span></span>|
|:-----|:-----|
|[<span data-ttu-id="ad15e-134">HrIStorageFromStream</span><span class="sxs-lookup"><span data-stu-id="ad15e-134">HrIStorageFromStream</span></span>](hristoragefromstream.md) <br/> |<span data-ttu-id="ad15e-135">创建访问流或锁定字节对象的存储对象。</span><span class="sxs-lookup"><span data-stu-id="ad15e-135">Creates a storage object to access a stream or lock bytes object.</span></span>  <br/> |
|[<span data-ttu-id="ad15e-136">OpenIMsgOnIStg</span><span class="sxs-lookup"><span data-stu-id="ad15e-136">OpenIMsgOnIStg</span></span>](openimsgonistg.md) <br/> |<span data-ttu-id="ad15e-137">创建访问存储对象的消息对象。</span><span class="sxs-lookup"><span data-stu-id="ad15e-137">Creates a message object to access a storage object.</span></span>  <br/> |
|[<span data-ttu-id="ad15e-138">OpenStreamOnFile</span><span class="sxs-lookup"><span data-stu-id="ad15e-138">OpenStreamOnFile</span></span>](openstreamonfile.md) <br/> |<span data-ttu-id="ad15e-139">创建 stream 对象，以访问文件。</span><span class="sxs-lookup"><span data-stu-id="ad15e-139">Creates a stream object to access a file.</span></span>  <br/> |
|[<span data-ttu-id="ad15e-140">WrapCompressedRTFStream</span><span class="sxs-lookup"><span data-stu-id="ad15e-140">WrapCompressedRTFStream</span></span>](wrapcompressedrtfstream.md) <br/> |<span data-ttu-id="ad15e-141">创建一个包含保存一条消息的格式文本 stream 的压缩文件或未压缩版本的 stream 对象。</span><span class="sxs-lookup"><span data-stu-id="ad15e-141">Creates a stream object that contains the compressed or uncompressed version of a stream holding the rich text of a message.</span></span>  <br/> |
   
 <span data-ttu-id="ad15e-142">**若要检索在给定的子存储的流的名称**</span><span class="sxs-lookup"><span data-stu-id="ad15e-142">**To retrieve the names of the streams in a given substorage**</span></span>
  
1. <span data-ttu-id="ad15e-143">调用子存储的**IStorage::EnumElements**方法以获取**IEnumSTATSTG**接口。</span><span class="sxs-lookup"><span data-stu-id="ad15e-143">Call the substorage's **IStorage::EnumElements** method to get an **IEnumSTATSTG** interface.</span></span> 
    
2. <span data-ttu-id="ad15e-144">调用**IEnumSTATSTG::Next**尽可能多**STATSTG**结构一次，您可以。</span><span class="sxs-lookup"><span data-stu-id="ad15e-144">Call **IEnumSTATSTG::Next** with as many **STATSTG** structures at a time as you can.</span></span> <span data-ttu-id="ad15e-145">如果每次请求的 100**下, 一步**将通常返回 S_FALSE _pceltFetched_的内容设置为实际检索到的号码。</span><span class="sxs-lookup"><span data-stu-id="ad15e-145">If you ask for 100 at a time, **Next** will usually return S_FALSE with the contents of  _pceltFetched_ set to the number that were actually retrieved.</span></span> 
    
3. <span data-ttu-id="ad15e-146">检查 STGTY_STREAM 与标记的**STATSTG**结构。</span><span class="sxs-lookup"><span data-stu-id="ad15e-146">Check for the **STATSTG** structures that are flagged with STGTY_STREAM.</span></span> 
    
4. <span data-ttu-id="ad15e-147">释放_pwcsName_参数。</span><span class="sxs-lookup"><span data-stu-id="ad15e-147">Release the  _pwcsName_ parameter.</span></span> 
    
 <span data-ttu-id="ad15e-148">**若要创建存储对象，以便访问现有流或锁定字节对象**</span><span class="sxs-lookup"><span data-stu-id="ad15e-148">**To create a storage object to access an existing stream or lock bytes object**</span></span>
  
- <span data-ttu-id="ad15e-149">客户端调用[HrIStorageFromStream](hristoragefromstream.md)。</span><span class="sxs-lookup"><span data-stu-id="ad15e-149">Clients call [HrIStorageFromStream](hristoragefromstream.md).</span></span> 
    
 <span data-ttu-id="ad15e-150">**若要创建邮件对象，以便访问现有的存储对象**</span><span class="sxs-lookup"><span data-stu-id="ad15e-150">**To create a message object to access an existing storage object**</span></span>
  
- <span data-ttu-id="ad15e-151">服务提供商和客户端调用[OpenIMsgOnIStg](openimsgonistg.md)。</span><span class="sxs-lookup"><span data-stu-id="ad15e-151">Service providers and clients call [OpenIMsgOnIStg](openimsgonistg.md).</span></span> <span data-ttu-id="ad15e-152">Message 对象创建不同的它不支持的所有通常由消息存储提供程序创建的消息对象[IMessage: IMAPIProp](imessageimapiprop.md)接口方法，如**IMessage::SubmitMessage**。</span><span class="sxs-lookup"><span data-stu-id="ad15e-152">The message object that is created differs from the message objects typically created by message store providers in that it does not support all of the [IMessage : IMAPIProp](imessageimapiprop.md) interface methods, such as **IMessage::SubmitMessage**.</span></span> <span data-ttu-id="ad15e-153">**OpenIMsgOnIStg**的可选输入的参数是一个符合[MSGCALLRELEASE](msgcallrelease.md)原型的回调函数。</span><span class="sxs-lookup"><span data-stu-id="ad15e-153">An optional input parameter to **OpenIMsgOnIStg** is a callback function that conforms to the [MSGCALLRELEASE](msgcallrelease.md) prototype.</span></span> <span data-ttu-id="ad15e-154">当邮件的引用计数为零时，由新的消息对象调用此函数。</span><span class="sxs-lookup"><span data-stu-id="ad15e-154">This function is called by the new message object when the message's reference count reaches zero.</span></span> <span data-ttu-id="ad15e-155">实现**MSGCALLRELEASE**函数可用于执行最终处理之前完全删除新邮件。</span><span class="sxs-lookup"><span data-stu-id="ad15e-155">Implementing a **MSGCALLRELEASE** function can be useful for performing final processing before the new message is completely removed.</span></span> 
    
<span data-ttu-id="ad15e-156">[OpenStreamOnFile](openstreamonfile.md)通常用于存储文件附件，因为它会创建流读取和写入文件。</span><span class="sxs-lookup"><span data-stu-id="ad15e-156">[OpenStreamOnFile](openstreamonfile.md) is commonly used for storing file attachments because it creates a stream that reads from and writes to a file.</span></span> <span data-ttu-id="ad15e-157">与**PR_ATTACH_DATA_BIN**属性标记为**OpenProperty**创建存储二进制附件数据的流。</span><span class="sxs-lookup"><span data-stu-id="ad15e-157">**OpenProperty** with **PR_ATTACH_DATA_BIN** as the property tag creates a stream for storing binary attachment data.</span></span> 
  
 <span data-ttu-id="ad15e-158">**压缩或解压缩包含富文本格式的消息文本的流**</span><span class="sxs-lookup"><span data-stu-id="ad15e-158">**To compress or uncompress a stream containing message text in the Rich Text Format**</span></span>
  
- <span data-ttu-id="ad15e-159">客户端调用[WrapCompressedRTFStream](wrapcompressedrtfstream.md)。</span><span class="sxs-lookup"><span data-stu-id="ad15e-159">Clients call [WrapCompressedRTFStream](wrapcompressedrtfstream.md).</span></span> <span data-ttu-id="ad15e-160">**WrapCompressedRTFStream**创建换行 RTF 流的流。</span><span class="sxs-lookup"><span data-stu-id="ad15e-160">**WrapCompressedRTFStream** creates a stream that wraps the RTF stream.</span></span> <span data-ttu-id="ad15e-161">包装流未实现的所有**IStream**方法;排除以下方法： **Seek**、 **SetSize**、**还原**、 **LockRegion**、 **UnlockRegion**、 **Stat**和**克隆**。</span><span class="sxs-lookup"><span data-stu-id="ad15e-161">The wrapper stream does not implement all of the **IStream** methods; the following methods are excluded: **Seek**, **SetSize**, **Revert**, **LockRegion**, **UnlockRegion**, **Stat**, and **Clone**.</span></span> <span data-ttu-id="ad15e-162">这是因为由**WrapCompressedRTFStream**创建的 stream 对象不支持**SetSize**或**Stat**，不可用于扩展或检索其大小简便方法。</span><span class="sxs-lookup"><span data-stu-id="ad15e-162">This is because the stream objects created by **WrapCompressedRTFStream** do not support either **SetSize** or **Stat**, there is not an easy way to either extend or retrieve their size.</span></span> <span data-ttu-id="ad15e-163">最佳策略是选取合理缓冲区大小和读取或写入循环。</span><span class="sxs-lookup"><span data-stu-id="ad15e-163">The best strategy is to pick a reasonable buffer size and read or write in a loop.</span></span>
    
> [!NOTE]
> <span data-ttu-id="ad15e-164">COM 具有存储对象实现基于从有问题的**EnumElements**方法返回一个**IEnumSTATSTG**对象的字节数组。</span><span class="sxs-lookup"><span data-stu-id="ad15e-164">COM has a storage object implementation based on a byte array that returns an **IEnumSTATSTG** object from the **EnumElements** method that is problematic.</span></span> <span data-ttu-id="ad15e-165">具体而言， **QueryInterface**方法不会无法正常工作。</span><span class="sxs-lookup"><span data-stu-id="ad15e-165">In particular, the **QueryInterface** method does not work correctly.</span></span> <span data-ttu-id="ad15e-166">服务提供程序实现使用 COM 实现自己存储对象应创建精简的**IEnumSTATSTG**对象的转发到基础**IEnumSTATSTG**方法的调用，但实现包装自己**AddRef**，**发布**、 **QueryInterface**和**Clone**方法。</span><span class="sxs-lookup"><span data-stu-id="ad15e-166">Service providers that implement their own storage objects using the COM implementation should create a thin wrapper for the **IEnumSTATSTG** object that forwards calls on to the underlying **IEnumSTATSTG** methods but implements its own **AddRef**, **Release**, **QueryInterface**, and **Clone** methods.</span></span> 
  

