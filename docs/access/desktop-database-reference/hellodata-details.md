---
title: HelloData 详细信息 （访问桌面数据库参考 （英文）
TOCTitle: HelloData Details
ms:assetid: db51e15c-1b5b-c64a-2f84-34dd0e78c6cf
ms:mtpsurl: https://msdn.microsoft.com/library/JJ250105(v=office.15)
ms:contentKeyID: 48548103
ms.date: 09/18/2015
mtps_version: v=office.15
ms.openlocfilehash: 6de174362e014af3e90686e53a563a10e04ec665
ms.sourcegitcommit: 19aca09c5812cfb98b68b5d4604dcaa814479df7
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/09/2018
ms.locfileid: "25466945"
---
# <a name="hellodata-details"></a><span data-ttu-id="1a835-102">HelloData 详细信息</span><span class="sxs-lookup"><span data-stu-id="1a835-102">HelloData Details</span></span>


<span data-ttu-id="1a835-103">**适用于**： Access 2013 |Office 2013</span><span class="sxs-lookup"><span data-stu-id="1a835-103">**Applies to**: Access 2013 | Office 2013</span></span>

<span data-ttu-id="1a835-104">通过典型的 ADO 应用程序的基本操作步骤 HelloData 应用程序： 获取、 检查、 编辑和更新数据。</span><span class="sxs-lookup"><span data-stu-id="1a835-104">The HelloData application steps through the basic operations of a typical ADO application: getting, examining, editing, and updating data.</span></span> <span data-ttu-id="1a835-105">启动应用程序时，单击第一个按钮，**获取数据**。</span><span class="sxs-lookup"><span data-stu-id="1a835-105">When you start the application, click the first button, **Get Data**.</span></span> <span data-ttu-id="1a835-106">这将运行 GetData() 子例程。</span><span class="sxs-lookup"><span data-stu-id="1a835-106">This will run the GetData() subroutine.</span></span>

## <a name="getdata"></a><span data-ttu-id="1a835-107">GetData</span><span class="sxs-lookup"><span data-stu-id="1a835-107">GetData</span></span>

<span data-ttu-id="1a835-108">GetData 将放在模块级变量，有效的连接字符串*m\_sConnStr*。</span><span class="sxs-lookup"><span data-stu-id="1a835-108">GetData places a valid connection string into a module-level variable, *m\_sConnStr*.</span></span> <span data-ttu-id="1a835-109">有关连接字符串的详细信息，请参阅 [创建连接字符串](creating-the-connection-string.md)。</span><span class="sxs-lookup"><span data-stu-id="1a835-109">For more information about connection strings, see [Creating the Connection String](creating-the-connection-string.md).</span></span>

<span data-ttu-id="1a835-p103">使用 Visual Basic **OnError** 语句指定错误处理程序。有关 ADO 中错误处理的详细信息，请参阅[第 6 章：错误处理](chapter-6-error-handling.md)。由于 HelloData 示例创建了一个断开连接的 *Recordset*，因此，将创建一个新的 **Connection** 对象并将 **CursorLocation** 属性设置为 **adUseClient**。这意味着从数据源提取数据后，与数据源的物理连接将被断开，但仍然可以使用 **Recordset** 对象中在本地缓存的数据。</span><span class="sxs-lookup"><span data-stu-id="1a835-p103">Assign an error handler using a Visual Basic **OnError** statement. For more information about error handling in ADO, see [Chapter 6: Error Handling](chapter-6-error-handling.md). A new **Connection** object is created, and the **CursorLocation** property is set to **adUseClient** because the HelloData example creates a *disconnected Recordset*. This means that once the data has been fetched from the data source, the physical connection with the data source is broken, but you can still work with the data that is cached locally in your **Recordset** object.</span></span>

<span data-ttu-id="1a835-114">打开连接后，将 SQL 字符串赋给变量 (sSQL)。</span><span class="sxs-lookup"><span data-stu-id="1a835-114">After the connection has been opened, assign a SQL string to a variable (sSQL).</span></span> <span data-ttu-id="1a835-115">然后实例化一个新的**Recordset**对象，m\_oRecordset1。</span><span class="sxs-lookup"><span data-stu-id="1a835-115">Then instantiate a new **Recordset** object, m\_oRecordset1 .</span></span> <span data-ttu-id="1a835-116">在下一行代码中，通过现有的**连接**，从而传递中打开**Recordset** 。</span><span class="sxs-lookup"><span data-stu-id="1a835-116">In the next line of code, open the **Recordset** over the existing **Connection**, passing in .</span></span> <span data-ttu-id="1a835-117">在下一行代码中，通过现有的**连接**，作为**Recordset**的数据源中 sSQL 传递打开**记录集**。</span><span class="sxs-lookup"><span data-stu-id="1a835-117">In the next line of code, open the **Recordset** over the existing **Connection**, passing in sSQL as the source of the **Recordset**.</span></span> <span data-ttu-id="1a835-118">将最后一个参数中的 **adCmdText** 传递给 **Recordset** 的 **Open** 方法，可以帮助 ADO 确定已作为 **Recordset** 的源传递的 SQL 字符串是命令的文本定义。</span><span class="sxs-lookup"><span data-stu-id="1a835-118">You assist ADO in making the determination that the SQL string you have passed as the source for the **Recordset** is a textual definition of a command by passing **adCmdText** in the final argument to the **Recordset** **Open** method.</span></span> <span data-ttu-id="1a835-119">此行还设置了与 **Recordset** 关联的 **LockType** 和 **CursorType** 。</span><span class="sxs-lookup"><span data-stu-id="1a835-119">This line also sets the **LockType** and **CursorType** associated with the **Recordset**.</span></span>

<span data-ttu-id="1a835-120">下一行代码将 **MarshalOptions** 属性设置为等于 **adMarshalModifiedOnly** 。</span><span class="sxs-lookup"><span data-stu-id="1a835-120">The next line of code sets the **MarshalOptions** property equal to **adMarshalModifiedOnly**.</span></span> <span data-ttu-id="1a835-121">**MarshalOptions** 指示应该将哪些记录封送到中间层（或 Web 服务器）。</span><span class="sxs-lookup"><span data-stu-id="1a835-121">**MarshalOptions** indicates which records should be marshaled to the middle tier (or Web server).</span></span> <span data-ttu-id="1a835-122">有关封送的详细信息，请参阅 COM 文档。</span><span class="sxs-lookup"><span data-stu-id="1a835-122">For more information about marshaling, see the COM documentation.</span></span> <span data-ttu-id="1a835-123">当使用客户端游标**adMarshalModifiedOnly** ([CursorLocation](cursorlocation-property-ado.md) = **adUseClient**)，仅在客户端已修改的记录写回中间层。</span><span class="sxs-lookup"><span data-stu-id="1a835-123">When using **adMarshalModifiedOnly** with a client-side cursor ([CursorLocation](cursorlocation-property-ado.md) = **adUseClient**), only records that have been modified on the client are written back to the middle tier.</span></span> <span data-ttu-id="1a835-124">将 **MarshalOptions** 设置为 **adMarshalModifiedOnly** 可以提高性能，因为封送的行较少。</span><span class="sxs-lookup"><span data-stu-id="1a835-124">Setting **MarshalOptions** to **adMarshalModifiedOnly** can improve performance because fewer rows are marshaled.</span></span>

<span data-ttu-id="1a835-p106">下一步，将 **ActiveConnection** 属性设置为等于 **Nothing** ，以断开 **Recordset** 的连接。有关详细信息，请参阅第 5 章"更新和保存数据"中的 [断开和重新连接记录集](disconnecting-and-reconnecting-the-recordset.md)一节。</span><span class="sxs-lookup"><span data-stu-id="1a835-p106">Next, disconnect the **Recordset** by setting its **ActiveConnection** property equal to **Nothing**. For more information, see [Disconnecting and Reconnecting the Recordset](disconnecting-and-reconnecting-the-recordset.md) in Chapter 5: Updating and Persisting Data.</span></span>

<span data-ttu-id="1a835-127">关闭数据源的连接并销毁现有的 **Connection** 对象，从而释放其耗用的资源。</span><span class="sxs-lookup"><span data-stu-id="1a835-127">Close the connection to the data source and destroy the existing **Connection** object, thereby releasing the resources it consumed.</span></span>

<span data-ttu-id="1a835-128">最后一步是在表单上将 Microsoft DataBound Grid 控件的 **Recordset** 设置为 **DataSource** ，这样，就可以轻松地在表单上显示 **Recordset** 中的数据。</span><span class="sxs-lookup"><span data-stu-id="1a835-128">The final step is to set the **Recordset** as the **DataSource** for the Microsoft DataBound Grid Control on the form so that you can easily display the data from the **Recordset** on the form.</span></span>

<span data-ttu-id="1a835-129">单击第二个按钮，**检查数据**。</span><span class="sxs-lookup"><span data-stu-id="1a835-129">Click the second button, **Examine Data**.</span></span> <span data-ttu-id="1a835-130">将运行 ExamineData 子例程。</span><span class="sxs-lookup"><span data-stu-id="1a835-130">This runs the ExamineData subroutine.</span></span>

## <a name="examinedata"></a><span data-ttu-id="1a835-131">ExamineData</span><span class="sxs-lookup"><span data-stu-id="1a835-131">ExamineData</span></span>

<span data-ttu-id="1a835-p108">ExamineData 使用 **Recordset** 对象的各种方法和属性来显示有关 **Recordset** 中数据的信息。该子例程通过 **RecordCount** 属性来报告记录数；在 **Recordset** 中循环并在表单的显示文本框中输出 **AbsolutePosition** 属性的值。此外，在该循环中，将第三条记录的 **Bookmark** 属性的值置于 Variant 变量 *vBookmark* 中供以后使用。</span><span class="sxs-lookup"><span data-stu-id="1a835-p108">ExamineData uses various methods and properties of the **Recordset** object to display information about the data in the **Recordset**. It reports the number of records by using the **RecordCount** property. It loops through the **Recordset** and prints the value of the **AbsolutePosition** property in the display text box on the form. Also while in the loop, the value of the **Bookmark** property for the third record is placed into a variant variable, *vBookmark*, for later use.</span></span>

<span data-ttu-id="1a835-p109">该例程使用以前存储的书签变量进行导航，直接回到第三条记录；调用 WalkFields 子例程，以便在 **Recordset** 的 **Fields** 集合中循环，并显示有关该集合中每个 **Field** 的详细信息。</span><span class="sxs-lookup"><span data-stu-id="1a835-p109">The routine navigates directly back to the third record using the bookmark variable that it stored earlier. The routine calls the WalkFields subroutine, which loops through the **Fields** collection of the **Recordset** and displays details about each **Field** in the collection.</span></span>

<span data-ttu-id="1a835-p110">最后，ExamineData 使用 **Recordset** 的 **Filter** 属性进行筛选，以便仅选取 CategoryId 等于 2 的那些记录。在表单的显示网格中，可以立即看到应用此筛选的结果。</span><span class="sxs-lookup"><span data-stu-id="1a835-p110">Finally, ExamineData uses the **Filter** property of the **Recordset** to screen for only those records with a CategoryId equal to 2. The result of applying this filter is immediately visible in the display grid on the form.</span></span>

<span data-ttu-id="1a835-140">有关 ExamineData 子例程中显示的功能的详细信息，请参阅[第 3 章：检查数据](chapter-3-examining-data.md)。</span><span class="sxs-lookup"><span data-stu-id="1a835-140">For more information about the functionality shown in the ExamineData subroutine, see [Chapter 3: Examining Data](chapter-3-examining-data.md).</span></span>

<span data-ttu-id="1a835-141">接下来，单击第三个按钮，**编辑数据**。</span><span class="sxs-lookup"><span data-stu-id="1a835-141">Next, click the third button, **Edit Data**.</span></span> <span data-ttu-id="1a835-142">这将运行 EditData 子例程。</span><span class="sxs-lookup"><span data-stu-id="1a835-142">This will run the EditData subroutine.</span></span>

## <a name="editdata"></a><span data-ttu-id="1a835-143">EditData</span><span class="sxs-lookup"><span data-stu-id="1a835-143">EditData</span></span>

<span data-ttu-id="1a835-144">当代码 EditData 子例程， **Recordset**仍上进行筛选 CategoryId 等于 2，仅符合筛选条件的那些项目都能看到是这样。</span><span class="sxs-lookup"><span data-stu-id="1a835-144">When the code enters the EditData subroutine, the **Recordset** is still filtered on CategoryId equal to 2, so only those items that meet the filter criteria are visible.</span></span> <span data-ttu-id="1a835-145">首次循环访问**Recordset**和价格浮动的**Recordset**中每个可见项增加 10%。</span><span class="sxs-lookup"><span data-stu-id="1a835-145">It first loops through the **Recordset** and increases the price of each visible item in the **Recordset** by 10 percent.</span></span> <span data-ttu-id="1a835-146">通过设置为等于大量新的有效的字段的**Value**属性更改的**价格**字段值。</span><span class="sxs-lookup"><span data-stu-id="1a835-146">The value of the **Price** field is changed by setting the **Value** property for that field equal to a new, valid amount.</span></span>

<span data-ttu-id="1a835-p113">请注意， **Recordset** 将与数据源断开连接。在 EditData 中所做的更改只对数据的本地缓存副本有效。有关详细信息，请参阅 [第 4 章：编辑数据](chapter-4-editing-data.md)。</span><span class="sxs-lookup"><span data-stu-id="1a835-p113">Remember that the **Recordset** is disconnected from the data source. The changes made in EditData are made only to the locally cached copy of the data. For more information, see [Chapter 4: Editing Data](chapter-4-editing-data.md).</span></span>

<span data-ttu-id="1a835-150">单击第四个按钮，**更新数据**之前，不会对数据源进行更改。</span><span class="sxs-lookup"><span data-stu-id="1a835-150">The changes will not be made on the data source until you click the fourth button, **Update Data**.</span></span> <span data-ttu-id="1a835-151">这将运行 UpdateData 子例程。</span><span class="sxs-lookup"><span data-stu-id="1a835-151">This will run the UpdateData subroutine.</span></span>

## <a name="updatedata"></a><span data-ttu-id="1a835-152">UpdateData</span><span class="sxs-lookup"><span data-stu-id="1a835-152">UpdateData</span></span>

<span data-ttu-id="1a835-153">UpdateData 首先删除已应用于 **Recordset** 的筛选器。</span><span class="sxs-lookup"><span data-stu-id="1a835-153">UpdateData first removes the filter that has been applied to the **Recordset**.</span></span> <span data-ttu-id="1a835-154">代码删除并重置的 Microsoft 绑定数据网格中的窗体上的作为**数据源**，以便筛选的**Recordset**显示在网格中。</span><span class="sxs-lookup"><span data-stu-id="1a835-154">The code removes and resets as the **DataSource** for the Microsoft Bound DataGrid on the form so that the unfiltered **Recordset** appears in the grid.</span></span>

<span data-ttu-id="1a835-155">然后，该代码将查看是否可以使用带有 **adMovePrevious** 参数的 **Supports** 方法在 **Recordset** 中向后移动。</span><span class="sxs-lookup"><span data-stu-id="1a835-155">The code then checks to see whether you can move backward in the **Recordset** by using the **Supports** method with the **adMovePrevious** argument.</span></span>

<span data-ttu-id="1a835-p116">该例程将使用 **MoveFirst** 方法移至第一条记录，并使用 **Field** 对象的 **OriginalValue** 和 **Value** 属性显示相应字段的原始值和当前值。这些属性以及 **UnderlyingValue** 属性（此处未使用）在 [第 5 章：更新和持久化数据](chapter-5-updating-and-persisting-data.md)中论述。</span><span class="sxs-lookup"><span data-stu-id="1a835-p116">The routine moves to the first record using the **MoveFirst** method and displays the field's original and current values, using the **OriginalValue** and **Value** properties of the **Field** object. These properties, along with the **UnderlyingValue** property (not used here), are discussed in [Chapter 5: Updating and Persisting Data](chapter-5-updating-and-persisting-data.md).</span></span>

<span data-ttu-id="1a835-p117">下一步，将创建一个新的 **Connection** 对象并使用该对象重新建立与数据源的连接。通过将新的 **Connection** 设置为 **Recordset** 的 **ActiveConnection** ，可以将 **Recordset** 重新连接到数据源。为将更新发送到服务器，该代码将对 **Recordset** 调用 **UpdateBatch** 。</span><span class="sxs-lookup"><span data-stu-id="1a835-p117">Next, a new **Connection** object is created and used to reestablish a connection to the data source. You reconnect the **Recordset** to the data source by setting the new **Connection** as the **ActiveConnection** for the **Recordset**. To send the updates to the server, the code calls **UpdateBatch** on the **Recordset**.</span></span>

<span data-ttu-id="1a835-161">如果批更新成功，模块级标志变量，，设置为 True。</span><span class="sxs-lookup"><span data-stu-id="1a835-161">If the batch update succeeds, a module-level flag variable, , is set to True.</span></span> <span data-ttu-id="1a835-162">这将提醒您稍后清理对数据库所做的所有更改。</span><span class="sxs-lookup"><span data-stu-id="1a835-162">This will remind you later to clean up all changes made to the database.</span></span>

<span data-ttu-id="1a835-p119">最后，该代码将移回 **Recordset** 中的第一条记录并显示原始值和当前值。调用 **UpdateBatch** 后，这些值是相同的。</span><span class="sxs-lookup"><span data-stu-id="1a835-p119">Finally, the code moves back to the first record in the **Recordset** and displays the original and current values. The values are the same after the call to **UpdateBatch**.</span></span>

<span data-ttu-id="1a835-165">有关更新数据的详细信息，包括在断开 **Recordset** 连接的情况下服务器上的数据发生更改时要执行的操作，请参阅 [第 5 章：更新和持久化数据](chapter-5-updating-and-persisting-data.md)。</span><span class="sxs-lookup"><span data-stu-id="1a835-165">For more detailed information about updating data, including what to do when data on the server changes while your **Recordset** is disconnected, see [Chapter 5: Updating and Persisting Data](chapter-5-updating-and-persisting-data.md).</span></span>

## <a name="formunload"></a><span data-ttu-id="1a835-166">窗体\_卸载</span><span class="sxs-lookup"><span data-stu-id="1a835-166">Form\_Unload</span></span>

<span data-ttu-id="1a835-167">窗体\_卸载子例程个几个原因而非常重要。</span><span class="sxs-lookup"><span data-stu-id="1a835-167">The Form\_Unload subroutine is important for several reasons.</span></span> <span data-ttu-id="1a835-168">首先，因为这是一个示例应用程序，窗体\_卸载清理到之前退出应用程序数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="1a835-168">First, because this is a sample application, Form\_Unload cleans up the changes made to the database before the application exits.</span></span> <span data-ttu-id="1a835-169">其次的代码演示如何在直接从打开的**Connection**对象使用**Execute**方法执行命令。</span><span class="sxs-lookup"><span data-stu-id="1a835-169">Second, the code shows how a command can be executed directly from an open **Connection** object using the **Execute** method.</span></span> <span data-ttu-id="1a835-170">最后，它显示执行非返回行 – 查询 （更新） 对数据源的示例。</span><span class="sxs-lookup"><span data-stu-id="1a835-170">Finally, it shows an example of executing a non-row–returning query (an UPDATE query) against the data source.</span></span>

