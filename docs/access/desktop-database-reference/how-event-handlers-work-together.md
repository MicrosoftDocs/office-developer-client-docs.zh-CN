---
title: 事件处理程序如何协同工作
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: e772e93f27d6bb5f30d865e3435d4bde6bdc5e73
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "32291920"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="7ee9d-102">事件处理程序如何协同工作</span><span class="sxs-lookup"><span data-stu-id="7ee9d-102">How event handlers work together</span></span>

<span data-ttu-id="7ee9d-103">**适用于**：Access 2013、Office 2013</span><span class="sxs-lookup"><span data-stu-id="7ee9d-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="7ee9d-p101">除非您正在用 Visual Basic 编程，否则不管实际上您是否处理所有事件，都必须实现 **Connection** 和 **Recordset** 事件的所有事件处理程序。必须完成的实现工作量取决于编程语言。有关详细信息，请参阅 [ADO 事件实例化（按语言）](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado)。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p101">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events. The amount of implementation work you have to do depends on your programming language. For more information, see [ADO Event Instantiation by Language](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="7ee9d-107">成对的事件处理程序</span><span class="sxs-lookup"><span data-stu-id="7ee9d-107">Paired event handlers</span></span>

<span data-ttu-id="7ee9d-p102">每个 Will 事件处理程序都有关联的 Complete 事件处理程序。例如，应用程序更改字段值时，将调用 **WillChangeField** 事件处理程序。如果更改是可接受的，则应用程序将保持 **adStatus** 参数不变，并执行操作。操作完成后， **FieldChangeComplete** 事件将通知应用程序操作已完成。如果操作成功完成， **adStatus** 将包含 **adStatusOK** ；否则， **adStatus** 将包含 **adStatusErrorsOccurred** ，并且您必须检查 **Error** 对象，以确定产生错误的原因。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p102">Each Will event handler has an associated Complete event handler. For example, when your application changes the value of a field, the **WillChangeField** event handler is called. If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed. When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished. If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="7ee9d-p103">调用 **WillChangeField** 时，您可能决定不进行更改。在此情况下，请将 **adStatus** 设置为 **adStatusCancel** 。这样，操作将取消，并且 **FieldChangeComplete** 事件将收到一个 **adStatus** 值： **adStatusErrorsOccurred** 。 **Error** 对象将包含 **adErrOperationCancelled** ，以便 **FieldChangeComplete** 处理程序知道操作已取消。但是，在更改 **adStatus** 参数的值之前，您需要对它进行检查，因为，如果在进入过程时将该参数设置为 **adStatusCantDeny** ，那么将 **adStatus** 设置为 **adStatusCancel** 是无效的。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p103">When **WillChangeField** is called, you might determine that the change should not be made. In that case, set **adStatus** to **adStatusCancel**. The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**. The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled. However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="7ee9d-p104">有时，操作可以引发多个事件。例如，对于 **Field** 更改和 **Record** 更改， **Recordset** 对象会提供有成对的事件。应用程序更改 **Field** 的值时，将调用 **WillChangeField** 事件处理程序。如果它确定操作可以继续，还会引发 **WillChangeRecord** 事件处理程序。如果此处理程序也允许事件继续，将执行更改，并调用 **FieldChangeComplete** 和 **RecordChangeComplete** 事件处理程序。调用特定操作的 Will 事件处理程序的顺序是未定义的，所以编写的代码应当避免依赖于按特定序列调用处理程序。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p104">Sometimes an operation can raise more than one event. For example, the **Recordset** object has paired events for **Field** changes and **Record** changes. When your application changes the value of a **Field**, the **WillChangeField** event handler is called. If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised. If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called. The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="7ee9d-p105">在实例中，当引发多个 Will 事件时，其中的一个事件可能会取消挂起的操作。例如，如果应用程序更改了 **Field** 的值，通常会调用 **WillChangeField** 和 **WillChangeRecord** 事件处理程序。但是，如果在第一个事件处理程序中取消了操作，则会通过 **adStatusOperationCancelled** 立即调用该处理程序关联的 Complete 处理程序。这样，永远不会调用第二个处理程序。但是，如果第一个事件处理程序允许事件继续，则会调用其他事件处理程序。如果这时它取消了操作，则两个 Complete 事件都会像在前面的示例中一样被调用。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p105">In instances when multiple Will events are raised, one of the events might cancel the pending operation. For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called. However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**. The second handler is never called. If, however, the first event handler allows the event to proceed, the other event handler will be called. If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="7ee9d-130">未配对的事件处理程序</span><span class="sxs-lookup"><span data-stu-id="7ee9d-130">Unpaired event handlers</span></span>

<span data-ttu-id="7ee9d-p106">只要传递给事件的状态不是 **adStatusCantDeny**，就可以通过在 *Status* 参数中返回 **adStatusUnwantedEvent** 来关闭任何事件的事件通知。例如，第一次调用 Complete 事件处理程序时，可以返回 **adStatusUnwantedEvent**。随后只会收到 Will 事件。但是，一些事件可以由于多个原因而触发。这种情况下，事件将有 *Reason* 参数。返回 **adStatusUnwantedEvent** 时，只有当事件由于特定原因而发生时，您才会停止收到该事件的通知。换句话说，对于每个可能触发事件的原因，您都有可能收到通知。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p106">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter. For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**. You will subsequently receive only Will events. However, some events can be triggered for more than one reason. In that case, the event will have a *Reason* parameter. When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason. In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="7ee9d-p107">如果需要检查将在操作中使用的参数，则可以使用单个 Will 事件处理程序。可以修改这些操作参数或取消操作。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p107">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation. You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="7ee9d-p108">或者，保持 Complete 事件通知处于启用状态。第一次调用 Will 事件处理程序时，返回 **adStatusUnwantedEvent** 。随后，您只会收到 Complete 事件。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p108">Alternatively, leave Complete event notification enabled. When your first Will event handler is called, return **adStatusUnwantedEvent**. You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="7ee9d-p109">单个 Complete 事件处理程序可以用于管理异步操作。每个异步操作都有相应的 Complete 事件。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p109">Single Complete event handlers can be useful for managing asynchronous operations. Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="7ee9d-145">例如，填充大型 [Recordset](recordset-object-ado.md) 对象可能需要很长时间。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="7ee9d-146">如果您的应用程序进行了适当的编写, 则可以启动操作并继续进行其他处理。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="7ee9d-147">最后，当 **ExecuteComplete** 事件填充 **Recordset** 时，您将得到通知。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="7ee9d-148">单个事件处理程序和多个对象</span><span class="sxs-lookup"><span data-stu-id="7ee9d-148">Single event handlers and multiple objects</span></span>

<span data-ttu-id="7ee9d-p111">Microsoft Visual C++ 等编程语言具有的灵活性使您能够用一个事件处理程序来处理多个对象的事件。例如，您可以用一个 **Disconnect** 事件处理程序处理几个 **Connection** 对象的事件。如果其中一个连接结束，则会调用该 **Disconnect** 事件处理程序。您可以确定哪个连接导致该事件，因为事件处理程序对象参数会设置为相应的 **Connection** 对象。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-p111">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects. For example, you could have one **Disconnect** event handler process events from several **Connection** objects. If one of the connections ended, the **Disconnect** event handler would be called. You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>

> [!NOTE]
> <span data-ttu-id="7ee9d-153">[!注释] 在 Visual Basic 中无法使用此技术，因为该语言只能将一个对象与一个事件处理程序相关。</span><span class="sxs-lookup"><span data-stu-id="7ee9d-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span>


