---
title: 创建 XLL
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: reference
keywords:
- dlls [excel 2007], 调用 excel, xlAutoFree 函数 [Excel 2007], xlAutoFree12 函数 [Excel 2007], xlcall32.lib [Excel 2007], xlAutoRegister 函数 [Excel 2007], xlcall.cpp [Excel 2007], xlAutoRemove 函数 [Excel 2007], xlAddInManagerInfo 函数 [Excel 2007], xlAutoAdd 函数 [Excel 2007], xlAutoOpen 函数 [Excel 2007], xlAutoClose 函数 [Excel 2007], DLLs [Excel 2007], 转换为 XLLs, XLLs [Excel 2007], 调用 Excel, xlAutoRegister12 函数 [Excel 2007], xlcall.h [Excel 2007], xlAddInManagerInfo12 函数 [Excel 2007]
ms.assetid: 7754998f-4e13-4a37-9724-43b6ee6c919b
description: 适用于：Excel 2013 | Office 2013 | Visual Studio
localization_priority: Priority
ms.openlocfilehash: 886b8e74f00f2e724785d43475ee0ffa3c922710
ms.sourcegitcommit: d6695c94415fa47952ee7961a69660abc0904434
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/17/2019
ms.locfileid: "28706742"
---
# <a name="creating-xlls"></a><span data-ttu-id="fc16d-104">创建 XLL</span><span class="sxs-lookup"><span data-stu-id="fc16d-104">Creating XLLs</span></span>

<span data-ttu-id="fc16d-105">**适用于**：Excel 2013 | Office 2013 | Visual Studio</span><span class="sxs-lookup"><span data-stu-id="fc16d-105">**Applies to**: Excel 2013 | Office 2013 | Visual Studio</span></span> 
  
<span data-ttu-id="fc16d-106">如果 DLL 是独立的或者依赖于其他库，则必须知道如何支持 Microsoft Excel 访问其函数和命令。</span><span class="sxs-lookup"><span data-stu-id="fc16d-106">If your DLL is self-contained or relies only on other libraries, you must know how to enable Microsoft Excel to access its functions and commands.</span></span> <span data-ttu-id="fc16d-107">有关详细信息，请参阅 [在 Excel 中的访问 DLL](how-to-access-dlls-in-excel.md)。</span><span class="sxs-lookup"><span data-stu-id="fc16d-107">For more information, see [Access DLLs in Excel](how-to-access-dlls-in-excel.md).</span></span> 
  
<span data-ttu-id="fc16d-108">但是，如果 DLL 需要访问 Excel 功能（例如，获取单元格的内容、调用工作表函数或询问 Excel 以获取工作区信息），则代码必须能够回调至 Excel。</span><span class="sxs-lookup"><span data-stu-id="fc16d-108">However, if your DLL needs to access Excel functionality (for example, to get the contents of a cell, to call a worksheet function, or to interrogate Excel to obtain workspace information), your code must be able to call back into Excel.</span></span>
  
<span data-ttu-id="fc16d-109">Excel C API 提供了多个支持 DLL 回调至 Excel 的函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-109">The Excel C API provides several functions that enable DLLs to call back into Excel.</span></span> <span data-ttu-id="fc16d-110">若要访问这些函数，必须在编译时将 DLL 静态链接至 Excel 32 位库 xlcall32.lib。</span><span class="sxs-lookup"><span data-stu-id="fc16d-110">To access these, the DLL must be linked statically at compile time with the Excel 32-bit library, xlcall32.lib.</span></span> <span data-ttu-id="fc16d-111">静态库可作为 Microsoft Excel 2013 XLL SDK 的一部分从 Microsoft 下载，其中包括 32 位和 64 位版本的静态库。</span><span class="sxs-lookup"><span data-stu-id="fc16d-111">The static library is downloadable from Microsoft as part of the Microsoft Excel 2013 XLL SDK, which includes both 32-bit and 64-bit versions of this library.</span></span>
  
## <a name="enabling-dlls-to-call-back-into-excel"></a><span data-ttu-id="fc16d-112">支持 DLL 回调至 Excel</span><span class="sxs-lookup"><span data-stu-id="fc16d-112">Enabling DLLs to Call Back into Excel</span></span>

<span data-ttu-id="fc16d-113">若要使 DLL 能够访问 Excel 中的功能并获取或设置工作区信息，必须先获取 Excel 回调函数 **Excel4**、**Excel4v**、**Excel12** 和 **Excel12v** 的地址。</span><span class="sxs-lookup"><span data-stu-id="fc16d-113">For a DLL to be able to access the functionality in Excel and get or set workspace information, it must first obtain the addresses of the Excel callback functions **Excel4**, **Excel4v**, **Excel12**, and **Excel12v**.</span></span> <span data-ttu-id="fc16d-114">最后两个回调函数是在 Excel 2007 中引入的，可用于后续版本中。</span><span class="sxs-lookup"><span data-stu-id="fc16d-114">The last two were introduced in Excel 2007 and are available in subsequent versions.</span></span> <span data-ttu-id="fc16d-115">若要访问所有这些函数，DLL 项目必须包括对 Excel 2013 XLL SDK 中的以下文件的引用。</span><span class="sxs-lookup"><span data-stu-id="fc16d-115">To access all of these, the DLL project must include references to the following files from the Excel 2013 XLL SDK.</span></span> <span data-ttu-id="fc16d-116">如果想要仅访问前两个回调函数（在任何版本的 Excel 中），则项目必须仅包括前两个文件。</span><span class="sxs-lookup"><span data-stu-id="fc16d-116">If you want to access only the first two callbacks (in any version of Excel), your project needs to include only the first two files.</span></span>
  
### <a name="xlcallh"></a><span data-ttu-id="fc16d-117">Xlcall.h</span><span class="sxs-lookup"><span data-stu-id="fc16d-117">Xlcall.h</span></span>

<span data-ttu-id="fc16d-118">Xlcall.h 文件包含以下项：</span><span class="sxs-lookup"><span data-stu-id="fc16d-118">The Xlcall.h file contains the following items:</span></span>
  
- <span data-ttu-id="fc16d-119">所有回调函数的函数属性。</span><span class="sxs-lookup"><span data-stu-id="fc16d-119">Function prototypes for all callback functions.</span></span>
    
- <span data-ttu-id="fc16d-120">回调函数用于交换 DLL/XLL 与 Excel 之间的数据的数据结构定义，以及数据类型常量定义。</span><span class="sxs-lookup"><span data-stu-id="fc16d-120">Definitions of the data structures that the callbacks use to exchange data between the DLL/XLL and Excel, and data-type constant definitions.</span></span>
    
- <span data-ttu-id="fc16d-121">工作表的 C API 函数和命令等效项、宏工作表函数和受支持的 Excel 命令的定义。</span><span class="sxs-lookup"><span data-stu-id="fc16d-121">Definitions of the C API function and command equivalents of the worksheet, macro sheet functions, and supported Excel commands.</span></span>
    
- <span data-ttu-id="fc16d-122">回调函数返回值的定义。</span><span class="sxs-lookup"><span data-stu-id="fc16d-122">Definitions of callback function return values.</span></span>
    
<span data-ttu-id="fc16d-123">应直接或间接通过用于访问 C API 或处理 C API 所使用数据类型的所有文件中的其他头文件，使用此文件的 **#include** 指令。</span><span class="sxs-lookup"><span data-stu-id="fc16d-123">You should use the **#include** directive for this file, directly or indirectly via another header file, in all files that access the C API or that handle data types that the C API uses.</span></span> 
  
### <a name="xlcall32lib"></a><span data-ttu-id="fc16d-124">Xlcall32.lib</span><span class="sxs-lookup"><span data-stu-id="fc16d-124">Xlcall32.lib</span></span>

<span data-ttu-id="fc16d-125">Xlcall32.lib 库将导出前两个回调函数 **Excel4** 和 **Excel4v** 以及 **XlCallVer** 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-125">The Xlcall32.lib library exports the first two callbacks, **Excel4** and **Excel4v**, and also the **XlCallVer** function.</span></span> <span data-ttu-id="fc16d-126">如果项目没有至此库的引用，当已在代码中使用任意上述回调函数时，链接器无法创建 XLL。</span><span class="sxs-lookup"><span data-stu-id="fc16d-126">Without a reference to this library in your project, the linker cannot create the XLL if you have used any of these callbacks in your code.</span></span> <span data-ttu-id="fc16d-127">（可以获取这些函数的地址，方法是动态链接至等效 Xlcall32.dll，后者已作为正常 Excel 安装的一部分复制到系统。）</span><span class="sxs-lookup"><span data-stu-id="fc16d-127">(You can obtain the addresses of these functions by linking dynamically to the equivalent Xlcall32.dll that is copied to your system as part of a normal Excel installation.)</span></span> 
  
### <a name="xlcallcpp"></a><span data-ttu-id="fc16d-128">Xlcall.cpp</span><span class="sxs-lookup"><span data-stu-id="fc16d-128">Xlcall.cpp</span></span>

<span data-ttu-id="fc16d-129">Excel 回调函数 **Excel12** 和 **Excel12v** 不会在 Xlcall32.lib 中导出。</span><span class="sxs-lookup"><span data-stu-id="fc16d-129">The Excel callbacks **Excel12** and **Excel12v** are not exported in Xlcall32.lib.</span></span> <span data-ttu-id="fc16d-130">这可确保自 Excel 2007 起创建的 XLL 项目同样也适用于更早版本的 Excel。</span><span class="sxs-lookup"><span data-stu-id="fc16d-130">This ensures that XLL projects that you create starting in Excel 2007 will also work with earlier versions of Excel.</span></span> <span data-ttu-id="fc16d-131">Xlcall.cpp 模块包含 **Excel12** 和 **Excel12v** 函数代码，这些函数将调用至 Excel 入口点（从 Excel 2007 起），或者在运行更早版本的 Excel 时返回安全错误值。</span><span class="sxs-lookup"><span data-stu-id="fc16d-131">The Xlcall.cpp module contains code for the **Excel12** and **Excel12v** functions, which call into an Excel entry point starting in Excel 2007, or return a safe error value if you are running an earlier version of Excel.</span></span> <span data-ttu-id="fc16d-132">如果想要创建的 XLL 能够在 Excel 2007 及之后的 Excel 版本中运行并且能够使用可处理较大网格和更长 Unicode 字符串的新数据类型，应在项目中包含此模块。</span><span class="sxs-lookup"><span data-stu-id="fc16d-132">You should include this module in your project if you want to create an XLL that runs starting in Excel 2007 and that is able to use the new data types that handle larger grids and longer Unicode strings.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="fc16d-133">从 Excel 2010 SDK 起，可以针对 32 位和 64 位 XLL 编译此文件。</span><span class="sxs-lookup"><span data-stu-id="fc16d-133">Starting with the Excel 2010 SDK, this file can be compiled for both 32-bit and 64-bit XLLs.</span></span> 
  
## <a name="turning-dlls-into-xlls-add-in-manager-interface-functions"></a><span data-ttu-id="fc16d-134">将 DLL 转换为 XLL：加载项管理器接口函数</span><span class="sxs-lookup"><span data-stu-id="fc16d-134">Turning DLLs into XLLs: Add-in Manager Interface Functions</span></span>

<span data-ttu-id="fc16d-135">XLL 是一种可导出多个程序的 DLL，这些程序供 Excel 或 Excel 加载项管理器调用。</span><span class="sxs-lookup"><span data-stu-id="fc16d-135">An XLL is a DLL that exports several procedures that are called by Excel or the Excel Add-in Manager.</span></span> <span data-ttu-id="fc16d-136">此处简要介绍了这些程序，[加载项管理器和 XLL 接口函数](add-in-manager-and-xll-interface-functions.md)中将会对它们进行详细介绍。</span><span class="sxs-lookup"><span data-stu-id="fc16d-136">These procedures are described briefly here and discussed in detail in [Add-in Manager and XLL Interface Functions](add-in-manager-and-xll-interface-functions.md).</span></span> <span data-ttu-id="fc16d-137">所有这些 DLL 回调函数均以前缀 **xlAuto** 开头。</span><span class="sxs-lookup"><span data-stu-id="fc16d-137">All of these DLL callbacks start with the prefix **xlAuto**.</span></span> <span data-ttu-id="fc16d-138">只有其中一种需要命令 **xlAutoOpen**。</span><span class="sxs-lookup"><span data-stu-id="fc16d-138">Only one of these, the command **xlAutoOpen**, is required.</span></span> <span data-ttu-id="fc16d-139">在激活加载项时将会调用此命令，它通常用于使用 Excel 注册 XLL 函数和命令以及执行其他初始化任务。</span><span class="sxs-lookup"><span data-stu-id="fc16d-139">It is called when the add-in is activated, and it is typically used to register XLL functions and commands with Excel and to do other initialization tasks.</span></span> <span data-ttu-id="fc16d-140">后面的章节中提供了所有 **xlAuto** 函数的函数签名和示例实施。</span><span class="sxs-lookup"><span data-stu-id="fc16d-140">The function signatures and example implementations of all of the **xlAuto** functions are provided in later sections.</span></span> 
  
<span data-ttu-id="fc16d-141">即便只有其中一种回调函数需要 **xlAutoOpen** 命令，加载项也可能需要基于其行为导出其他项。</span><span class="sxs-lookup"><span data-stu-id="fc16d-141">Even though **xlAutoOpen** is the only required one of these callbacks, your add-in may also need to export others depending on its behavior.</span></span> 
  
<span data-ttu-id="fc16d-142">Excel 2007 中引入了新的数据类型 **XLOPER12**，以适应更大的网格和支持 Unicode 长字符串。</span><span class="sxs-lookup"><span data-stu-id="fc16d-142">Excel 2007 introduced a new data type, **XLOPER12**, to accommodate larger grids and to support long Unicode strings.</span></span> <span data-ttu-id="fc16d-143">本主题后面介绍了 **XLOPER12**。</span><span class="sxs-lookup"><span data-stu-id="fc16d-143">**XLOPER12** is described later in this topic.</span></span> <span data-ttu-id="fc16d-144">尽管 **xlAuto** 函数采用或返回旧数据类型 **XLOPER**，在 Excel 2007 中引入的新版函数将使用 **XLOPER12** 数据类型。</span><span class="sxs-lookup"><span data-stu-id="fc16d-144">Whereas **xlAuto** functions take or return the old data type **XLOPER**, new versions of these functions were introduced in Excel 2007 that use **XLOPER12** data types.</span></span> <span data-ttu-id="fc16d-145">除了 **xlAutoFree12** 外（有时必须使用它来避免 **XLOPER12** 内存泄漏），你可以放心地省略所有版本 12 **xlAuto** 函数，因为在此情况下，Excel 2007 及以后版本的 Excel 将会调用 **XLOPER** 版本。</span><span class="sxs-lookup"><span data-stu-id="fc16d-145">With the exception of **xlAutoFree12**, which you must sometimes implement to avoid **XLOPER12** memory leaks, you can safely omit all the version 12 **xlAuto** functions, in which case, starting in Excel 2007, Excel calls the **XLOPER** versions.</span></span> 
  
### <a name="xlautoopen"></a><span data-ttu-id="fc16d-146">xlAutoOpen</span><span class="sxs-lookup"><span data-stu-id="fc16d-146">xlAutoOpen</span></span>

<span data-ttu-id="fc16d-147">激活 XLL 时，Excel 将会调用 [xlAutoOpen](xlautoopen.md) 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-147">Excel calls the [xlAutoOpen](xlautoopen.md) function whenever the XLL is activated.</span></span> <span data-ttu-id="fc16d-148">如果加载项在正常结束的最后一个 Excel 会话中处于活动状态，则会在 Excel 会话开始时激活该加载项。</span><span class="sxs-lookup"><span data-stu-id="fc16d-148">The add-in will be activated at the start of an Excel session if it was active in the last Excel session that ended normally.</span></span> <span data-ttu-id="fc16d-149">在 Excel 会话期间加载加载项也会将其加载。</span><span class="sxs-lookup"><span data-stu-id="fc16d-149">The add-in is activated if it is loaded during an Excel session.</span></span> <span data-ttu-id="fc16d-150">可以在 Excel 会话期间停用和重新激活加载项，并且将在重新激活时调用函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-150">The add-in can be deactivated and reactivated during an Excel session, and the function is called on reactivation.</span></span> 
  
<span data-ttu-id="fc16d-151">应使用 **xlAutoOpen** 注册 XLL 函数和命令，初始化数据结构，自定义用户界面等等。</span><span class="sxs-lookup"><span data-stu-id="fc16d-151">You should use **xlAutoOpen** to register XLL functions and commands, initialize data structures, customize the user interface, and so on.</span></span> 
  
<span data-ttu-id="fc16d-152">如果加载项实施和导出 [xlAutoRegister](xlautoregister-xlautoregister12.md) 函数或 [xlAutoRegister12](xlautoregister-xlautoregister12.md) 函数，则 Excel 可能会尝试激活和注册函数和命令，而不先调用 **xlAutoOpen** 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-152">If your add-in implements and exports the [xlAutoRegister](xlautoregister-xlautoregister12.md) function or the [xlAutoRegister12](xlautoregister-xlautoregister12.md) function, Excel might attempt to activate and register a function or command without first calling the **xlAutoOpen** function.</span></span> <span data-ttu-id="fc16d-153">在此情况下，应确保充分初始化加载项，以便函数或命令正常运行。</span><span class="sxs-lookup"><span data-stu-id="fc16d-153">In this case, you should ensure that your add-in is sufficiently initialized for your function or command to work properly.</span></span> <span data-ttu-id="fc16d-154">如果未充分初始化，则尝试注册函数或命令或者执行必要初始化将会失败。</span><span class="sxs-lookup"><span data-stu-id="fc16d-154">If it is not, you should either fail the attempt to register the function or command, or carry out the necessary initialization.</span></span> 
  
### <a name="xlautoclose"></a><span data-ttu-id="fc16d-155">xlAutoClose</span><span class="sxs-lookup"><span data-stu-id="fc16d-155">xlAutoClose</span></span>

<span data-ttu-id="fc16d-156">停用 XLL 时，Excel 将调用 [xlAutoClose](xlautoclose.md) 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-156">Excel calls the [xlAutoClose](xlautoclose.md) function whenever the XLL is deactivated, that is, unloaded from memory.</span></span> <span data-ttu-id="fc16d-157">当 Excel 会话正常结束时，将会停用加载项。</span><span class="sxs-lookup"><span data-stu-id="fc16d-157">The add-in is deactivated when an Excel session ends normally.</span></span> <span data-ttu-id="fc16d-158">如果用户在 Excel 会话期间停用加载项，则会调用函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-158">If the user deactivates the add-in during an Excel session, the function is called.</span></span> 
  
<span data-ttu-id="fc16d-159">应使用 **xlAutoClose** 注销函数和命令，发布资源，撤销自定义项等等。</span><span class="sxs-lookup"><span data-stu-id="fc16d-159">You should use **xlAutoClose** to unregister functions and commands, release resources, undo customizations, and so on.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="fc16d-160">注销函数和命令时存在一个已知问题。</span><span class="sxs-lookup"><span data-stu-id="fc16d-160">There is a known issue with the unregistration of functions and commands.</span></span> <span data-ttu-id="fc16d-161">有关详细信息，请参阅 [Excel XLL 开发中的已知问题](known-issues-in-excel-xll-development.md)。</span><span class="sxs-lookup"><span data-stu-id="fc16d-161">For more information, see [Known Issues in Excel XLL Development](known-issues-in-excel-xll-development.md).</span></span> 
  
### <a name="xlautoadd"></a><span data-ttu-id="fc16d-162">xlAutoAdd</span><span class="sxs-lookup"><span data-stu-id="fc16d-162">xlAutoAdd</span></span>

<span data-ttu-id="fc16d-163">在 Excel 会话期间，如果用户使用加载项管理器激活 XLL，则 Excel 将调用 [xlAutoAdd](xlautoadd.md) 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-163">Excel calls the [xlAutoAdd function](xlautoadd.md) whenever the user activates the XLL during an Excel session by using the Add-In Manager.</span></span> <span data-ttu-id="fc16d-164">当 Excel 启动并加载预安装的加载项时，不会调用此函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-164">This function is not called when Excel starts and loads a preinstalled add-in.</span></span> 
  
<span data-ttu-id="fc16d-165">可以使用此函数来显示用于通知用户加载项已激活的自定义对话框、读取或写入注册表或者检查许可信息。</span><span class="sxs-lookup"><span data-stu-id="fc16d-165">You can use this function to display a custom dialog box that tells the user that the add-in has been activated, to read from or write to the registry, or to check licensing information.</span></span>
  
### <a name="xlautoremove"></a><span data-ttu-id="fc16d-166">xlAutoRemove</span><span class="sxs-lookup"><span data-stu-id="fc16d-166">xlAutoRemove</span></span>

<span data-ttu-id="fc16d-167">在 Excel 会话期间，如果用户使用加载项管理器停用 XLL，则 Excel 将调用 [xlAutoRemove](xlautoremove.md) 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-167">Excel calls the [xlAutoRemove](xlautoremove.md) function whenever the user deactivates the XLL during an Excel session by using the Add-In Manager.</span></span> <span data-ttu-id="fc16d-168">如果在已安装加载项的情况下 Excel 会话正常或异常关闭，则不会调用此函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-168">This function is not called when an Excel session closes, normally or abnormally, with the add-in installed.</span></span> 
  
<span data-ttu-id="fc16d-169">可以使用此函数来显示用于通知用户加载项已停用的自定义对话框，或者读取或写入注册表。</span><span class="sxs-lookup"><span data-stu-id="fc16d-169">You can use this function to display a custom dialog box that tells the user that the add-in has been deactivated, or to read from or write to the registry.</span></span>
  
### <a name="xladdinmanagerinfoxladdinmanagerinfo12"></a><span data-ttu-id="fc16d-170">xlAddInManagerInfo/xlAddInManagerInfo12</span><span class="sxs-lookup"><span data-stu-id="fc16d-170">xlAddInManagerInfo/xlAddInManagerInfo12</span></span>

<span data-ttu-id="fc16d-171">在 Excel 会话中首次调用加载项管理器时，Excel 将调用 [xlAddInManagerInfo](xladdinmanagerinfo-xladdinmanagerinfo12.md) 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-171">Excel calls the [xlAddInManagerInfo](xladdinmanagerinfo-xladdinmanagerinfo12.md) function when the Add-in Manager is invoked for the first time in an Excel session.</span></span> <span data-ttu-id="fc16d-172">如果 Excel 传递一个等于 1 的参数，则此函数应返回一个字符串（通常为加载项的名称）；否则，它将返回 **#VALUE!**。</span><span class="sxs-lookup"><span data-stu-id="fc16d-172">If Excel passes an argument equal to 1, this function should return a string (typically, the name of the add-in); otherwise, it should return **#VALUE!**.</span></span>
  
<span data-ttu-id="fc16d-173">从 Excel 2007 起，如果 Excel 是通过 XLL 导出，则它将优先调用 **xlAddInManagerInfo12** 函数，而不是 **xlAddInManagerInfo** 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-173">Starting in Excel 2007, Excel calls the **xlAddInManagerInfo12** function in preference to the **xlAddInManagerInfo** function if it is exported by the XLL.</span></span> <span data-ttu-id="fc16d-174">**xlAddInManagerInfo12** 函数的工作方式应与 **xlAddInManagerInfo** 函数相同，以免在 XLL 行为中出现特定于版本的差异。</span><span class="sxs-lookup"><span data-stu-id="fc16d-174">The **xlAddInManagerInfo12** function should work in the same way as the **xlAddInManagerInfo** function to avoid version-specific differences in the behavior of the XLL.</span></span> <span data-ttu-id="fc16d-175">**xlAddInManagerInfo12** 函数应返回 **XLOPER12** 数据类型，而 **xlAddInManagerInfo** 函数应返回 **XLOPER** 数据类型。</span><span class="sxs-lookup"><span data-stu-id="fc16d-175">The **xlAddInManagerInfo12** function should return an **XLOPER12** data type, whereas the **xlAddInManagerInfo** function should return an **XLOPER** data type.</span></span> 
  
### <a name="xlautoregisterxlautoregister12"></a><span data-ttu-id="fc16d-176">xlAutoRegister/xlAutoRegister12</span><span class="sxs-lookup"><span data-stu-id="fc16d-176">xlAutoRegister/xlAutoRegister12</span></span>

<span data-ttu-id="fc16d-177">如果已调用 XLM 函数 **REGISTER** 或 C API [xlfRegister](xlfregister-form-1.md) 等效函数，且注册的函数中缺少返回值和参数类型，则 Excel 将调用 [xlAutoRegister](xlautoregister-xlautoregister12.md) 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-177">Excel calls the [xlAutoRegister](xlautoregister-xlautoregister12.md) function whenever a call has been made to the XLM function **REGISTER**, or the C API equivalent [xlfRegister](xlfregister-form-1.md) function, with the return and argument types missing for the function being registered.</span></span> <span data-ttu-id="fc16d-178">**xlAutoRegister** 函数允许 XLL 搜索其内部的已导出函数和命令列表，以注册带有参数的函数和返回指定类型。</span><span class="sxs-lookup"><span data-stu-id="fc16d-178">The **xlAutoRegister** function allows the XLL to search its internal lists of exported functions and commands to register the function with the argument and return the specified types.</span></span> 
  
<span data-ttu-id="fc16d-179">从 Excel 2007 起，如果 Excel 是通过 XLL 导出，则它将优先调用 **xlAddInRegister12** 函数，而不是 **xlAddInRegister** 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-179">Starting in Excel 2007, Excel calls the **xlAddInRegister12** function in preference to the **xlAddInRegister** function if it is exported by the XLL.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="fc16d-180">如果 **xlAddInRegister**/ **xlAddInRegister12** 尝试注册函数而不提供参数和返回值类型，则会发生递归调用循环，这最终会溢出调用堆栈并导致 Excel 关闭或停止响应。</span><span class="sxs-lookup"><span data-stu-id="fc16d-180">If **xlAddInRegister**/ **xlAddInRegister12** tries to register the function without supplying the argument and return types, a recursive calling loop occurs that eventually overflows the call stack and causes Excel to close or stop responding.</span></span> 
  
### <a name="xlautofreexlautofree12"></a><span data-ttu-id="fc16d-181">xlAutoFree/xlAutoFree12</span><span class="sxs-lookup"><span data-stu-id="fc16d-181">xlAutoFree/xlAutoFree12</span></span>

<span data-ttu-id="fc16d-182">在 XLL 工作表函数返回 **XLOPER**/ **XLOPER12** 数据类型后，如果显示了通知 Excel XLL 仍需释放内存的标志集时，则 Excel 将调用 [xlAutoFree/xlAutoFree12](xlautofree-xlautofree12.md) 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-182">Excel calls the [xlAutoFree/xlAutoFree12](xlautofree-xlautofree12.md) function just after an XLL worksheet function returns an **XLOPER**/ **XLOPER12** data type with a flag set that tells Excel there is memory that the XLL still needs to release.</span></span> <span data-ttu-id="fc16d-183">这将会使 XLL 动态返回已分配的数组、字符串以及没有内部泄漏的工作表的外部引用。</span><span class="sxs-lookup"><span data-stu-id="fc16d-183">This enables the XLL to return dynamically allocated arrays, strings, and external references to the worksheet without memory leaks.</span></span> <span data-ttu-id="fc16d-184">从 Excel 2007 起，**XLOPER12** 数据类型受支持。</span><span class="sxs-lookup"><span data-stu-id="fc16d-184">Starting in Excel 2007, the **XLOPER12** data type is supported.</span></span> <span data-ttu-id="fc16d-185">有关详细信息，请参阅 [Excel 中的内存管理](memory-management-in-excel.md)。</span><span class="sxs-lookup"><span data-stu-id="fc16d-185">For more information, see [Memory Management in Excel](memory-management-in-excel.md).</span></span>
  
> [!NOTE]
> <span data-ttu-id="fc16d-186">从 Excel 2007 起，如果 Excel 已配置为使用多线程工作表重新计算，则会在刚用于调用所返回函数的函数的相同线程上调用 **xlAutoFree**/ **xlAutoFree12** 函数。</span><span class="sxs-lookup"><span data-stu-id="fc16d-186">Starting in Excel 2007, when Excel is configured to use multithreaded worksheet recalculation, the **xlAutoFree**/ **xlAutoFree12** function is called on the same thread that was just used to call the function that returned it.</span></span> <span data-ttu-id="fc16d-187">在对该线程上的任何后续工作表单元格进行求值之前，始终调用 **xlAutoFree**/ **xlAutoFree12**。</span><span class="sxs-lookup"><span data-stu-id="fc16d-187">The call to **xlAutoFree**/ **xlAutoFree12** is always made before any subsequent worksheet cells are evaluated on that thread.</span></span> <span data-ttu-id="fc16d-188">这可以简化 XLL 中的线程安全设计。</span><span class="sxs-lookup"><span data-stu-id="fc16d-188">This simplifies thread-safe design in your XLL.</span></span> <span data-ttu-id="fc16d-189">有关详细信息，请参阅 [Excel 中的多线程重新计算](multithreaded-recalculation-in-excel.md)。</span><span class="sxs-lookup"><span data-stu-id="fc16d-189">For more information, see [Multithreaded Recalculation in Excel](multithreaded-recalculation-in-excel.md).</span></span> 
  
### <a name="creating-64-bit-xlls"></a><span data-ttu-id="fc16d-190">创建 64 位 XLL</span><span class="sxs-lookup"><span data-stu-id="fc16d-190">Creating 64-bit XLLs</span></span>

<span data-ttu-id="fc16d-191">Excel 和用户定义的函数可在 64 位操作系统上运行，以充分利用 32 位操作系统所没有的性能优势。</span><span class="sxs-lookup"><span data-stu-id="fc16d-191">Excel and user-defined functions can run on 64-bit operating systems to take advantage of performance benefits over 32-bit operating systems.</span></span> <span data-ttu-id="fc16d-192">Excel 将传递其中包含有关数据类型信息的 **XLOPER12** 结构中的值。</span><span class="sxs-lookup"><span data-stu-id="fc16d-192">Excel passes values in **XLOPER12** structures that include information about the types for the data.</span></span> <span data-ttu-id="fc16d-193">转换 **XLOPER12** 结构与本机类型（如 **int** 或指针）之间的值以保留更大类型的值时，请务必谨慎。</span><span class="sxs-lookup"><span data-stu-id="fc16d-193">Be careful when you convert between values in the **XLOPER12** structure and native types like **int** or pointers to preserve the values in the larger type.</span></span> 
  
## <a name="see-also"></a><span data-ttu-id="fc16d-194">另请参阅</span><span class="sxs-lookup"><span data-stu-id="fc16d-194">See also</span></span>



[<span data-ttu-id="fc16d-195">从“函数向导”或“替换”对话框调用 XLL 函数</span><span class="sxs-lookup"><span data-stu-id="fc16d-195">Call XLL functions from the Function Wizard or Replace dialog boxes</span></span>](how-to-call-xll-functions-from-the-function-wizard-or-replace-dialog-boxes.md)
  
[<span data-ttu-id="fc16d-196">加载项管理器和 XLL 接口函数</span><span class="sxs-lookup"><span data-stu-id="fc16d-196">Add-in Manager and XLL Interface Functions</span></span>](add-in-manager-and-xll-interface-functions.md)
  
[<span data-ttu-id="fc16d-197">开发 Excel XLL</span><span class="sxs-lookup"><span data-stu-id="fc16d-197">Developing Excel XLLs</span></span>](developing-excel-xlls.md)

